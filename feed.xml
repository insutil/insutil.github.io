<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://insutil.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://insutil.github.io/" rel="alternate" type="text/html" /><updated>2020-03-02T23:43:23+09:00</updated><id>https://insutil.github.io/feed.xml</id><title type="html">사람과 기술을 연결하는 도구 제작소</title><subtitle></subtitle><author><name>insutil</name></author><entry><title type="html">양방향 순환참조 문제해결</title><link href="https://insutil.github.io/issue/2020/03/02/jpa-jsonignore/" rel="alternate" type="text/html" title="양방향 순환참조 문제해결" /><published>2020-03-02T00:00:00+09:00</published><updated>2020-03-02T00:00:00+09:00</updated><id>https://insutil.github.io/issue/2020/03/02/jpa-jsonignore</id><content type="html" xml:base="https://insutil.github.io/issue/2020/03/02/jpa-jsonignore/">&lt;p&gt;실무에서 처음으로 JPA를 사용해 프로젝트를 진행하다 보니 크고 작은 문제들이 여기저기 불쑥불쑥 튀어나온다.&lt;/p&gt;
&lt;p&gt;이번에 겪은건 Controller 에서 Entity class 를 json 형태로 리턴하는 와중에 마딱들였다.&lt;/p&gt;
&lt;p class=&quot;magt30&quot;&gt;N:1, 1:N 의 양방향 매핑관계를 맺고있는 entity를 별도의 DTO 를 이용하지 않고 리턴했더니,&lt;/p&gt;
&lt;p&gt;이때까지 자바 개발을 하면서 보았던 어떤 에러메시지 보다 길고 긴 에러메시지를 보게되었다. &lt;/p&gt;

&lt;p class=&quot;f20 magt30 magb30 fwb&quot;&gt;양방향 N:1 1:N 관계 설정&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/75682884-7d6a5280-5cd9-11ea-934a-86d930ac1274.jpg&quot; width=&quot;900&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/75682901-81967000-5cd9-11ea-86eb-08ce334e3c34.jpg&quot; width=&quot;900&quot; class=&quot;magt20&quot;&gt;&lt;/p&gt;

&lt;p&gt;ManyToOne 의 default fetch 타입은 EAGER 이지만, LAZY로 강제 설정했다.&lt;/p&gt;
&lt;P&gt;LIST 의 SIZE 만 체크했기 때문에 LAZY 설정에 의해 연관관계에 있는 Entity를 실제 load 하지는 않고 프록시 타입을 반환한다.&lt;/P&gt;
&lt;p&gt;여기까지는 아무문제가 없었는데, Controller 에서 MessageConveter에 의해 JSON으로 변환되어 응당되는 과정에서 연관관계의 엔티티도 불러온다.&lt;/p&gt;
&lt;p&gt;바로 여기서, 순환참조 문제가 발생한다. A-&gt;B, B-&gt;A 로 참조가 무한 반복되는 문제가 발생한다.&lt;/p&gt;

&lt;p class=&quot;f20 fwb magt50 magb30&quot;&gt;해결방법&lt;/p&gt;
&lt;p class=&quot;&quot;&gt;1. @JsonIgnore : 이 어노테이션을 붙이면 json 데이터에 해당 프로퍼티는 null로 들어가게 된다. 즉, 데이터에 아예 포함이 안되게 된다. (내가 적용한 방법.)&lt;/p&gt;
&lt;p class=&quot;magt20&quot;&gt;2. @JsonManagedReference와 @JsonBackReference : 이 두개의 어노테이션이야말로 순환참조를 방어하기 위한 Annotation이다.
	연관관계의 비주인 Entity에 @JsonManagedReference를, 연관관계 주인 Entity에 @JsonBackReference 어노테이션을 추가해주면 된다.&lt;/p&gt;
&lt;p class=&quot;magt20&quot;&gt;3. DTO 사용 : 위와 같은 상황이 발생하게 된 주 원인은 '양방향 맵핑'이기도 하지만, 더 정확하게는 entity 자체를 리턴한데에 있다.
	entity 자체를 return 하지 말고, DTO 객체를 만들어 필요한 데이터만 옮겨담아 client로 리턴하면 순환참조와 관련된 문제는 예방할 수 있다.&lt;/p&gt;
&lt;p class=&quot;magt20&quot;&gt;4. 맵핑 재설정 : 양방향 맵핑이 꼭 필요한지 다시 한번 생각해볼 필요가 있다. 만약 양쪽에서 접근 할 필요가 없다면 단방향 맵핑을 하면 자연스레 순환참조가 해결된다.&lt;/p&gt;
&lt;p class=&quot;magt50 dblue&quot;&gt;※ 개인적으로 생각하는 BEST 전략은 반드시 양방향 매핑 관계과 필요한지 파악하고, 그렇다면 결과는 항상 DTO 를 만들어서 반환하는게 좋다고 본다.&lt;/p&gt;</content><author><name>김도영</name><email>kdy6721@gmail.com</email></author><category term="[&quot;issue&quot;]" /><summary type="html">실무에서 처음으로 JPA를 사용해 프로젝트를 진행하다 보니 크고 작은 문제들이 여기저기 불쑥불쑥 튀어나온다. 이번에 겪은건 Controller 에서 Entity class 를 json 형태로 리턴하는 와중에 마딱들였다. N:1, 1:N 의 양방향 매핑관계를 맺고있는 entity를 별도의 DTO 를 이용하지 않고 리턴했더니, 이때까지 자바 개발을 하면서 보았던 어떤 에러메시지 보다 길고 긴 에러메시지를 보게되었다.</summary></entry><entry><title type="html">Generic (1)</title><link href="https://insutil.github.io/study/2020/01/19/generic/" rel="alternate" type="text/html" title="Generic (1)" /><published>2020-01-19T00:00:00+09:00</published><updated>2020-01-19T00:00:00+09:00</updated><id>https://insutil.github.io/study/2020/01/19/generic</id><content type="html" xml:base="https://insutil.github.io/study/2020/01/19/generic/">&lt;p&gt;자바 를 학습하면서 가장 난해한것 중의 하나가 제네릭이 아닌가 싶다.&lt;/p&gt;
&lt;p&gt;알다가도 모르겠고, 모르겠다가도 알것같은 것이 제네릭이다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;그래서 이번 포스팅에선 제네릭에 대해 학습한 내용을 기록하고자 한다.&lt;/p&gt;
&lt;p&gt;아래의 순서로 이번 포스팅을 정리해 나갈것이다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;ⓐ 제네릭이란&lt;/p&gt;
&lt;p&gt;ⓑ 왜 제네릭을 사용하는가&lt;/p&gt;
&lt;p&gt;ⓒ Raw type&lt;/p&gt;
&lt;p&gt;ⓓ 제네릭 메서드&lt;/p&gt;
&lt;p&gt;ⓔ 제한된 타입 파라미터 (Bounded Type Parameter)&lt;/p&gt;
&lt;p&gt;ⓕ 제네릭 상속&lt;/p&gt;
&lt;p&gt;ⓖ 타입 추론&lt;/p&gt;
&lt;p&gt;ⓗ 와일드 카드&lt;/p&gt;
&lt;p&gt;ⓘ 와일드 카드 캡쳐&lt;/p&gt;
&lt;p&gt;ⓙ Intersection type&lt;/p&gt;
&lt;p&gt;ⓚ Type token&lt;/p&gt;
&lt;p&gt;ⓛ Syper type token&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;그럼 제일 먼제 제네릭이란.. 클래스 혹은 메서드에서 사용할 타입을 외부에서 지정함으로써&lt;/p&gt;
&lt;p&gt;컴파일 시점에 구체적인 타입이 결정되도록 하는것 이다.&lt;/p&gt;

&lt;p class=&quot;magt30 magb10&quot;&gt;[그림 1]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71414279-83203800-2699-11ea-82d4-b1faba5e68e2.jpg&quot; width=&quot;500&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;그림과 같이 클래스에 'T' 라는 파라미터 타입을 추가했고, 인스턴스 생성시 다이아몬드 연산자를 이용해 타입 아규먼트 (type argument) 를 지정할 수 있다.&lt;/p&gt;
&lt;p&gt;예시로 든 그림을 보면 String 이라는 기본 데이터 타입 (Primitive data type) 을 지정해서 인스턴스 를 생성했고,&lt;/p&gt;
&lt;p&gt;전달된 타입 파라미터는 Type Variable 로써 작용을 해서 멤버변수의 타입까지 지정하고 있다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;다름으로 왜 제네릭을 사용해야 이유에 대해 얘기해 보자.&lt;/p&gt;
&lt;p&gt;대표적인 이유는 다음과 같다.&lt;/p&gt;

&lt;p&gt;● 컴파일 시점에서의 강력한 타입 체크&lt;/p&gt;
&lt;p&gt;● 불필요한 타입 변환 제거&lt;/p&gt;
&lt;p&gt;● 코드 재활용&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;이중 컴파일 시점에서의 체크에 대한 그림을 보고 넘어가자.&lt;/p&gt;
&lt;p class=&quot;magb20&quot;&gt;[그림 2]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71414841-34c06880-269c-11ea-87a9-6e1ab8cb49cf.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt20&quot;&gt;다음에 언급할 raw type 형태의 리스트를 Integer 로 선언 후 문자열을 add 하고 있다.&lt;/p&gt;
&lt;p&gt;그런데 컴파일러는 어떤 오류 신호도 보내지 않고 있다.&lt;/p&gt;
&lt;p&gt;바로 장애로 이어질 수 있는 상황이다.&lt;/p&gt;
&lt;p&gt;하지만 제네릭을 사용했다면 컴파일러의 강력한 타입 체크 기능을 통해 사전에 오류를 확인할 수 있었을 것이다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;방금 언급된 raw type 은 제네릭을 얘기할때 빠지지 않고 등장한다.&lt;/p&gt;
&lt;p&gt;그럼 raw type 이란 뭘까 ??&lt;/p&gt;
&lt;p&gt;바로 타입 파라미터가 없는 제네릭 타입을 말한다.&lt;/p&gt;
&lt;p class=&quot;magt30&quot;&gt;[그림 3]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/70857506-1c7d7a80-1f33-11ea-9e0b-613cb7e2a9bb.png&quot;&gt;&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;그림에서 'generic' 이 바로 Raw type 변수이다.&lt;/p&gt;
&lt;p&gt;분명 Generics 이라는 클래스는 Generic 타입으로 정의되었지만 generics 라는 변수는&lt;/p&gt;
&lt;p&gt;실 타입 매개변수 즉 타입 파라미터가 없이 선언되었다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;같은 이유로 List&lt;E&gt; 로 선언된 Generic Interface 를 List list = Arrays.asList(1,2,3);&lt;/p&gt;
&lt;p&gt;처럼 사용하는것 역시 Raw type 을 사용하는 것이 된다.&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;그런데 raw type 을 사용할때는 반드시 숙지해야할 사항이 있다.&lt;/p&gt;

&lt;p class=&quot;magt10&quot;&gt;그전에 사실 지금의 자바에서는 raw type 을 사용하지 말것을 권장한다.&lt;/p&gt;
&lt;p&gt;raw type 자체가 자바5 이전의 하위버전 호환성을 위한 것인데 이걸 정확한 이해없이&lt;/p&gt;
&lt;p&gt;사용하다가는 디버깅이 까다로운 런타임 에러를 만나게될 여지를 항상 내포하고 있기 때문이다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;그럼 raw type 의 사용은 가능한 피하되 꼭 써야한다면 반드시 알아야 할것은......&lt;/p&gt;
&lt;p&gt;바로 raw Type의 슈퍼 클래스는 raw Type 이란 것이다.&lt;/p&gt;
&lt;p&gt;거기에 상속 받지 않은 raw type 의 생성자, 인스턴스 메서드, 필드 역시 모두 raw type 이 된다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;즉 raw type을 사용할시 타입 파라미터 &lt;b&gt;&lt;T&gt;&lt;/b&gt; 를 완전히 지워버리게 되는것이다.&lt;/p&gt;
&lt;p&gt;거기에다가 Super type 타입 파라미터도 지우고 해당 클래스의 생성자, 메서드, 필드 에 정의된&lt;/p&gt;
&lt;p&gt;모든 타입 파라미터를 지워버린다. (무시무시 하다;;)&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;[그림 4]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;img src=&quot;https://user-images.githubusercontent.com/55611187/70857649-f86f6880-1f35-11ea-9c89-fb5dcf0e826d.png&quot;&gt;&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;그러다 보니 그림4 와 같은 오류가 발생하게 된다.&lt;/p&gt;
&lt;p&gt;위에서 언급한데로 Raw type의 모든 메서드는 raw type 이 된다.&lt;/p&gt;
&lt;p&gt;그래서 List&amp;ltString&amp;gt -&gt; List 가 되고,&lt;/p&gt;
&lt;p&gt;따라서 getString이 반환하는 요소는 String 이 아닌 Object 타입으로 판정되어&lt;/p&gt;
&lt;p&gt;String 으로 선언된 변수에 Object 타입을 대입할 수 없어서 에러가 발생하게 되는것이다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;raw type을 얘기하면서 타입 파라미터를 지운다는 언급을 했었다.&lt;/p&gt;
&lt;p&gt;이에 소거자 (Type erasure) 에 대해서도 짧게 얘기해 보고자 한다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;사실 우리가 작성하는 모든 제네릭 정보는 런타임시에 모두 제거된다.&lt;/p&gt;
&lt;p&gt;(몇가지 예외 case 가 있긴 하다, 서브가 슈퍼를 확장하면서 타입을 지정할 경우 타입정보가 소거되지 않는다.&lt;/p&gt;
&lt;p&gt;또 Upper bounded 에서 특정 타입의 sub 여야 한다에서 extends 뒤에 오는 슈퍼 타입의 정보도&lt;/p&gt;
&lt;p&gt;컴파일하고 남아 런타임에도 사용 됩니다.)&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;이렇게 소거자를 통해 타입정보를 제거하는 이유는 하위 버전과의 호환때문이다.&lt;/p&gt;
&lt;p&gt;C#은 호환성 따위 바로 무시해버리는 쪽을 택했는데, Java 는 지독스러울 정도로 하위 버전과의&lt;/p&gt;
&lt;p&gt;호환을 중요시 생각하는것 같다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;어쨌든 소거자에 의해 List&amp;ltString&amp;gt list = new ArrayList&lt;&gt;(); 여기서 'String' 과 같은&lt;/p&gt;
&lt;p&gt;제네릭 정보는 모두 소거된다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;근데 여기서 그럼 어떻게 이런 프로그램이 실행되는지가 궁금할 수 있는데,&lt;/p&gt;
&lt;p&gt;그건 컴파일러가 컴파일 타임에 제네릭 정보를 체크해서 코드에 casting 코드를 추가해놓기 때문이다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;raw type 과 소거자 에 대해서는 이정도만 언급하고 넘어가겠다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.8&quot; target=&quot;_blank&quot;&gt;JLS 4.8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;해당 링크를 참조하자.&lt;/p&gt;


&lt;p class=&quot;magt30&quot;&gt;이번엔 제네릭 메서드를 알아보자.&lt;/p&gt;
&lt;p&gt;제네릭 메서드란.. 메서드가 받는 파라미터의 타입을 고정하지 않고,&lt;/p&gt;
&lt;p&gt;어떤 타입의 파라미터가 들어오든 그 타입의 파라미터를 이용해서 동일한 작업을 수행하고 싶을 경우&lt;/p&gt;
&lt;p&gt;class level 이 아닌 method level 의 return type 앞에 type parameter 를 선언하여 사용할 수 있게 하는것이다.&lt;/p&gt;
&lt;p&gt;제네릭 메서드는 instance method 뿐 아니라 static method 에도 사용가능하다.&lt;/p&gt;
&lt;p&gt;type parameter 정보가 method level 에서 정의되기 때문에 static 이라도 상관 없다.&lt;/p&gt;
&lt;p&gt;하지만 문제가 되는 경우가 있다 '그림 5' 를 보자.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;[그림 5]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71426573-0455ea00-26ef-11ea-9353-23380f3ca4a2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;'그림 5' 의  'E' 라는 type parameter(type variable) 는 클래스의 인스턴스가 생성될때 받아 오는데&lt;/p&gt;
&lt;p&gt;static 메서드는 instance 없이 사용하기 때문에 'E' 가 어떤 타입이 될지 알 수 없어 컴파일러가 에러를 발생시킨다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;하지만 그림 6 처럼 사용하는것은 가능은 하다.&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;[그림 6]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71426626-bf7e8300-26ef-11ea-9f02-b80f9b97cf61.jpg&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;그림 6 을 보면 class level 의 type parameter 'E' 와 method level 의 type parameter 'E' 를 각자 지정&lt;/p&gt;
&lt;p&gt;한 경우 인데 이런 경우 'E' 가 어디에 속한 것인지 헷갈릴 수 있으니 다른 이름으로 사용하자.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;[그림 7]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71426658-4df30480-26f0-11ea-9d0c-ed3c6117d9dd.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt20&quot;&gt;'그림 7' 처럼 class level 의 type parameter, method level 의 type parameter 을 같이 사용 할 수도 있다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;제네릭 메서드에 대한 설명은 이정도로 하고 제한된 타입 파라미터에 대해 알아보자.&lt;/p&gt;
&lt;p&gt;제한된 타입 파라미터는 사용하는 타입 파라미터의 타입에 경계(제한) 를 설정하는 것을 말한다.&lt;/p&gt;
&lt;p&gt;bounded type parameter 이라고도 하는데 상위타입 제한, 하위타입 제한 으로 나뉜다.&lt;/p&gt;
&lt;p&gt;하위타입 제한은 와일드 카드에 대해 얘기할때 보기로 하고 상위 타입에 대해 간단한 예제를 보자.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;[그림 8]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71427075-189de500-26f7-11ea-980e-9904510eac36.jpg&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;magt10&quot;&gt;'그림 8' 을 보면 Comparable 을 구현한 모든 타입 파라미터로 제한 하고 있다.&lt;/p&gt;
&lt;p&gt;즉 Comparable 을 구현하지 않은 타입은 올 수 없다.&lt;/p&gt;
&lt;p&gt;Java 는 연산자 오버 로딩을 지원하지 않기 때문에 short, int, double 등과 같은 primitive 타입에만&lt;/p&gt;
&lt;p&gt;'&gt;', '+' 와 같은 (비교)연산자를 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;이 문제를 해결하기 위해 Comparable 인터페이스와 재귀적 타입 바운드를 활용하는 예제이다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;이처럼 무한대의 타입을 받아서 처리할 수 있는 generic 한 메서드 이면서도&lt;/p&gt;
&lt;p&gt;구현에 꼭 필요한 타입 제약 조건을 걸고 싶을때 타입 제한 파라미터를 사용할 수 있다.&lt;/p&gt;


&lt;p class=&quot;magt30&quot;&gt;이번엔 제네릭 상속에 대해 알아볼 차례다.&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;[그림 9]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71427815-c57c6000-26ff-11ea-96c0-602eebfa490f.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;그림의 첫부분을 보면 Number type 변수 에 Integer 타입을 대입하고 있고 아무 문제가 없는 코드이다.&lt;/p&gt;
&lt;p&gt;Number 가 Integer 의 수퍼 타입이기 때문에 당연하다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;그렇다면 List&amp;ltNumber&amp;gt 는 List&amp;ltInteger&amp;gt 의 수퍼타일까? 그림에서 보듯이 정답은 '&lt;b&gt;아니오&lt;/b&gt;' 이다.&lt;/p&gt;
&lt;p&gt;Number 는 Integer 의 수퍼타입 이 맞지만, List&amp;ltNumber&amp;gt 은 List&amp;ltInteger&amp;gt 의 수퍼타입이 아니다.&lt;/p&gt;
&lt;p&gt;다시 말해 type parameter 사이에 상속 관계가 있다고 해서,&lt;/p&gt;
&lt;p&gt;type parameter 가 적용된 클래스 (제네릭 타입) 사이의 상속 관계에 영향을 주진 않는다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;그럼 이런 경우는 상속관계가 성립할까?&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;[그림 10]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71427961-d9749180-2700-11ea-94ed-3b115633cf3e.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;보다시피 성립한다. List&amp;ltInteger&amp;gt 는 ArrayList&amp;ltInteger&amp;gt 의 수퍼타입이 맞다.&lt;/p&gt;

&lt;p&gt;이런 예시도 성립한다.&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;[그림 11]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71428004-32dcc080-2701-11ea-9995-dc3292fd2f9f.jpg&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;magt10&quot;&gt;이상으로 제네릭 상속에 대해 간단히 알아봤다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;이번엔 타입추론 에 대해 얘기해볼 차례이다.&lt;/p&gt;
&lt;p&gt;타입추론 이란, 주로 메서드 호출할때 호출하는 정보를(type argument) 를 보고&lt;/p&gt;
&lt;p&gt;메서드 선언부의 type parameter 에 실제 어떤 타입이 들어가야할지 컴파일러가 체크해주는 걸 말한다.&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;[그림 12]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71428082-d0d08b00-2701-11ea-89bf-cefd12c9f63b.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;그림 의 주석을 보면 알수 있듯이 메서드의 호출부를 보고 타입 파라미터의 타입을 컴파일러가 추론함으로써&lt;/p&gt;
&lt;p&gt;아무 이상없는 정상적으로 작동하는 코드가 된다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;[그림 13]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71428143-46d4f200-2702-11ea-9f6b-50ae8f4459eb.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;주석으로 그림에 대한 설명을 대신하겠다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;이제 와일드 카드를 알아보자.&lt;/p&gt;

&lt;p class=&quot;magt10&quot;&gt;[그림 14]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71433462-97f4de00-2722-11ea-90e6-6e18f32eb14d.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;위에서 부터 익숙한 제네릭 을 사용하고 있다.&lt;/p&gt;
&lt;p&gt;타입이 정해지면 타입을 알고 타입을 사용하겠다는 뜻이다.&lt;/p&gt;
&lt;p&gt;밑에 '?' 를 사용하는 부분이 와일드 카드 이다.&lt;/p&gt;
&lt;p&gt;타입을 모르고 알필요도 없고 오직 리스트가 가진 기능만 사용하 된다는 뜻이다.&lt;/p&gt;
&lt;p&gt;즉 리스트의 요소와 결부되는 add 와 같은 메서드는 사용하지 않겠다는 것이다. (add(null) 은 가능)&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;그 아래의 예제는 간단한 상속관계를 가지는 두 클래스를 가지고 와일드 카드를 사용하는 모습니다.&lt;/p&gt;
&lt;p&gt;List&amp;lt? extends A&amp;gt listA = listB; 가 가능한 이유는 B 가 A의 서브이기 때문에 상위타입 제한을 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;List&amp;lt? super B&amp;gt lb = listB; 가 가능한 이유는 와일드 카드는 항상 자신을 포함하기 때문이다.&lt;/p&gt;
&lt;p&gt;위의 경우 A타입 혹은 A타입의 서브타입, B타입 혹은 B타입의 수퍼타입 이 올 수있다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;이번엔 메서드를 사용한 예제를 보자.&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;[그림 15]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71433901-2a967c80-2725-11ea-81d6-7f43fe38b7ed.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;주석을 보면 알 수 있듯이 타입 파라미터를 사용하겠다고 지정할 경우 메서드의 여러군데서 사용이 가능하다.&lt;/p&gt;
&lt;p&gt;반연에 와일드 카드를 사용한 코드는 리스트 혹은 오브젝트 타입이 제공하는 기능만 사용 가능하다.&lt;/p&gt;
&lt;p&gt;구체적인 어떤 값을 사용할 경우 컴파일 에러가 발생한다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;[그림 16]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71434071-228b0c80-2726-11ea-9143-e419ab30fac8.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;그림16 을 보면 타입 파라미터가 의미있게 쓰이지 않는다.&lt;/p&gt;
&lt;p&gt;그렇다면 와일드카드로 대체해도 되지 않을까?&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;[그림 17]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71434150-7d246880-2726-11ea-83d2-dc61cc5976bc.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;사실 그림16 은 그림17 로 작성되어야 맞다.&lt;/p&gt;
&lt;p&gt;제네릭을 와일드 카드로 대체해도 문제될 부분이 전혀 없는 코드이다.&lt;/p&gt;
&lt;p&gt;리스트의 원소를 의미있게 사용하는 부분이 없기에 와일드 카드를 사용하는 것이 타당하다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;[그림 18]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71434276-076ccc80-2727-11ea-91f7-631aaab80cd8.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;또 다른 예제인데 주석에 적은것 처럼 와일드카드로 (그림19) 대체 되어야 타당한 코드이다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;[그림 19]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71434343-5d417480-2727-11ea-9242-c3727c40e49e.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;그림18에 와일드 카드를 적용한 코드이다.&lt;/p&gt;
&lt;p&gt;각각 Lower bounded(하위한정), Upper bounded(상위한정) wild card 를 사용하고 있다.&lt;/p&gt;
&lt;p&gt;compareTo 를 통해 비교 대상이 되는 인수는 'T' 의 sub type 이어도 이상없는 자연스러운 코드 이다.&lt;/p&gt;
&lt;p&gt;그렇다면 Comparable 에는 왜 Lower bounded Wild card 를 사용했을까?&lt;/p&gt;
&lt;p&gt;Java 레퍼런스를 보면 메서드 내에서 의미있게 사용될 경우 상위한정(Upper bounded wild card) 을&lt;/p&gt;
&lt;p&gt;반면 메서드 외부에서 소비되거나 내부에서 사용되지 않을 경우 하위한정(Lower bounded) 를 사용하라고 되어 있다.&lt;/p&gt;
&lt;p&gt;그런데 Effective java 에서는 같은 맥락이지만 조금 다르게 설명한다.&lt;/p&gt;
&lt;p&gt;PECS (Producer-extends, Consumer-super) 다시말해 타입 T 가 생산자라면 extends 를&lt;/p&gt;
&lt;p&gt;소비자라면 super 를 사용 하라는 뜻이다.&lt;/p&gt;
&lt;p class=&quot;magt20&quot;&gt;&lt;b&gt;[그림20]&lt;/b&gt; 의 maxWithWildCard 메서드를 보면 Type argument 를 받아들이는 list 의 type parameter 의 경우&lt;/p&gt;
&lt;p&gt;메서드 내에서 T 타입의 각 요소들을 비교하고 그 결과로 max 에 해당하는 T 타입의 결과물을 생산하고 있다.&lt;/p&gt;
&lt;p&gt;반면 Comparable 의 compareTo 에 사용되는 T 타입은 메서드 외부의 compareTo 라는 메서드에 의해&lt;/p&gt;
&lt;p&gt;비교 대상으로 대입되어 그저 소모되고 있다.&lt;/p&gt;
&lt;p&gt;PECS 에 정확히 부합하고 있다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;[그림 20]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71434505-2fa8fb00-2728-11ea-9b5c-25a881de0dd5.jpg&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;마지막 예시를 보자.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;[그림 21]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71434737-1eacb980-2729-11ea-85f3-99f3e5172cba.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;list 의 타입 파라미터는 Number 이고 list 의 실제 요소인 Integer 은 Number 의 하위 타입이다.&lt;/p&gt;
&lt;p&gt;상위타입 으로 하위 타입을 받는건 전혀 문제될게 없다.&lt;/p&gt;
&lt;p&gt;Comparator 부분을 보면 Object type 이다. 실제 비교되는 요소들은 Integer 이지만&lt;/p&gt;
&lt;p&gt;상위 타입인 Object 로 비교하고 있다. 역시 상위 타입으로 하위타입을 비교하는건 문제되지 않는다.&lt;/p&gt;
&lt;p&gt;정리해보면 T 타입의 하위 타입을 T 타입의 상위타입과 비교하는 것이므로 자연스러운 코드 이다.&lt;/p&gt;
&lt;p&gt;Collections 의 max 함수 정의 부분과 정확히 일치한다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;이쯤에서 와일드 카드에 대한 정리를 마무리하겠다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;[그림 22]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71438427-19f00180-2739-11ea-8a5a-eb33f137ca0e.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;그림22 의 오류 메시지를 보면 캡처가 어쩌구~ 하는 내용이 보인다.&lt;/p&gt;
&lt;p&gt;도대체 뭘 캡처 한다는거지.. 처음 해당 메시지를 마주하면 당황하게 된다.&lt;/p&gt;
&lt;p&gt;캡처에러는 와일드 카드를 사용할 경우 타입을 알 수 없다고 한것인데, 경우에 따라&lt;/p&gt;
&lt;p&gt;타입을 추론해야 하는 상황이 있는데 이를 할 수 없을 경우 발생한다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;이러한 캡처에러를 회피하는 방법은 몇가지가 있는데, 당연히 와이들 카드를 제네릭으로 대체하면&lt;/p&gt;
&lt;p&gt;회피가 가능하고, 다른방법으로 raw type 과 helper 메서드를 이용하는 방법이 있다.&lt;/p&gt;
&lt;p&gt;raw type 의 사용은 지양해야 한다고 했으니 이에 대한 설명은 제외 하고 헬퍼 메서드를 사용하는 경우를 살펴보자.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;[그림 23]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71439261-3fcad580-273c-11ea-8548-9cb6f23ef771.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;주석에도 간단히 적었지만 추가로 언급해 보자면,&lt;/p&gt;
&lt;p&gt;wild card 를 넘겨 받아서 제네릭 으로 받는 메서드를 호출하고 있다.&lt;/p&gt;
&lt;p&gt;이게 가능한 경우는 List&amp;lt?&amp;gt 과 List&amp;ltT&amp;gt 이 일치하거나 List&amp;ltT&amp;gt 가 슈퍼 타입일 경우 가능하지만 지금의 예제는 그런 관계는 없다.&lt;/p&gt;
&lt;p&gt;wild card 가 적용된 list 를 argument 로 해서 helper 메서드를 호출할때 컴파일러는 이미 list의 타입을 알고 캡쳐해둔다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;캡처에러를 만나면 당황하지 말고 어떤식으로 타입을 구체화 할 수 있을지 고민해보고, 제네릭을 사용하거나&lt;/p&gt;
&lt;p&gt;이러한 헬퍼 메서드를 사용해도 무방하다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;인터섹션 타입에 대해 얘기할 차례인데, 이를 실무에서 활용하는 경우는 드물것이라 본다.&lt;/p&gt;
&lt;p&gt;나 역시 이를 실무에서 사용해본 경험이 없고, 제네릭 이란 녀석이 제대로 알고 사용하기가 참 힘든 녀석인거 같다.&lt;/p&gt;
&lt;p&gt;이런게 있다는 것 정도만 알고 넘어가는 수준에서 언급하겠다.&lt;/p&gt;
&lt;p&gt;그림24 를 보자.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;[그림 24]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71439696-f54a5880-273d-11ea-9f83-022d3e9e174b.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;보는것 처럼 람다식도 캐스팅이 가능하다.&lt;/p&gt;
&lt;p&gt;이걸 응용하여 인터페이스를 '&amp;' 로 연결하여 기능을 확장한 하나의 새로운 타입을 인터섹션 타입이라 한다.&lt;/p&gt;
&lt;p&gt;이때 주의 할 점은 연결된 모음에서 클래스는 단 1개만 올 수 있고,&lt;/p&gt;
&lt;p&gt;인터페이스 를 합쳐서 추상메서드는 단 1개만 있어야 한다는 것이다.&lt;/p&gt;
&lt;p&gt;우리가 정의한 인터페이스도 얼마든지 사용가능 하지만, 사용된 인터페이스의 추상메서드 가 2개 이상일 경우 에러가 발생한다.&lt;/p&gt;
&lt;p&gt;단 defualt, static 메서드는 상관이 없다.&lt;/p&gt;
&lt;p&gt;이점을 활용하여 보통은 마커 인터페이스 라고 하는 인터페이스를 정의해서 사용하는 경우가 대부분 이다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;예를 들어 그림25 처럼 활용할 수 있다.&lt;/p&gt;
&lt;p&gt;[그림 25]&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/71440015-3abb5580-273f-11ea-8473-2ac303bdae32.jpg&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;magt10&quot;&gt;임의로 정의한 Upper, BlankRemove, Hello, World 메서드를 자바에서 제공하는 Function 인터페이스와 함께 사용하여&lt;/p&gt;
&lt;p&gt;각각의 인터페이스가 제공하는 모든 기능을 활용할 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;여기서도 타입추론이 적용된 모습을 볼 수 있는데, 컴파일러가 이정도는 가뿐히 처리해준다.&lt;/p&gt;
&lt;p&gt;최종적으로 Consumer 로 받아서 accept 로 최종 기능을 적용하고 있다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;어찌보면 신기하기도 하고, 이를 어떻게 적용하고 활용할지는 각자의 몫이다.&lt;/p&gt;

&lt;p class=&quot;magt10&quot;&gt;타입 토큰에 대한 부분도 정리하려 했는데, 이는 별도의 포스팅으로 다루겠다. (힘듬ㅠ)&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;많은 시간을 들여 학습하고 정리했는데, 생략한 부분도 많고, 아쉬움이 많이 남는다.&lt;/p&gt;
&lt;p&gt;기회가 되면 제네릭 부분은 다시 한번 정리해 보겠다.&lt;/p&gt;</content><author><name>김도영</name><email>kdy6721@gmail.com</email></author><category term="[&quot;study&quot;]" /><summary type="html">자바 를 학습하면서 가장 난해한것 중의 하나가 제네릭이 아닌가 싶다. 알다가도 모르겠고, 모르겠다가도 알것같은 것이 제네릭이다.</summary></entry><entry><title type="html">String(문자열) 완전 정복</title><link href="https://insutil.github.io/study/2019/12/15/string/" rel="alternate" type="text/html" title="String(문자열) 완전 정복" /><published>2019-12-15T00:00:00+09:00</published><updated>2019-12-15T00:00:00+09:00</updated><id>https://insutil.github.io/study/2019/12/15/string</id><content type="html" xml:base="https://insutil.github.io/study/2019/12/15/string/">&lt;h2 style=&quot;color: #005cbf&quot;&gt;안녕하세요! 신입사원 장현입니다.&lt;/h2&gt;
&lt;h6&gt;포스팅에 맛들려서 이렇게 두 번째 포스팅을 하게 되었습니다. 부디 첫 포스팅보다 더 나아지길 바라며 글을 작성해봅니다...&lt;/h6&gt;
&lt;br/&gt;
자바로 프로그래밍하게 되면 자바의 문자열을 이리저리 가공하여 쓰는 경우가 허다합니다.
&lt;br/&gt;
물론 여러분들처럼 프로그래밍 고수분들은 식은 죽 먹기로 화려하게 가공하시겠지만,
&lt;br/&gt;
저같은 초보개발자는 막상 문자열을 자르거나 추출해야하는 업무를 맡으면 땀 뻘뻘 흘리면서 구글링을 하겠죠 ㅠㅠ
&lt;br/&gt;

안그래도 초보 개발자들은 개발이 느린데 이러한 문제로 더 느려지는 것을 방지하기 위해
&lt;br/&gt;
그.래.서 제가 이렇게 문자열 완전 정복이라는 주제로 글을 쓰게 되었습니다.
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;아래는 String이 가지는 기본 메서드입니다.&lt;/h3&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;1. char charAt(int index)&lt;/h3&gt;&lt;br/&gt;
- index(정수)의 문자를 읽어냅니다.&lt;br/&gt;
예) &quot;abcde&quot;.charAt(2) 는 'c'가 읽어집니다. 0부터 시작하기 때문에 3 번째인 c가 읽어지는 것입니다.&lt;br/&gt;
반환 값은 이름에서 알다시피 char 형태로 반환이 됩니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;2. int codePointAt(int index)&lt;/h3&gt;&lt;br/&gt;
- 이것도 charAt과 마찬가지로 index로 접근하여 문자를 읽어내지만 반환값은 유니코드(int 형)로 반환합니다&lt;br/&gt;
예) &quot;abcde&quot;.codePointAt(0) 은 a의 유니코드인 97를 반환합니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;3. int codePointBefore(int index)&lt;/h3&gt;&lt;br/&gt;
- 와우... codePointAt과 똑같지만, 한가지 다른 점이 있다면 codePointAt는 시작 index가 1부터 시작합니다&lt;br/&gt;
말로 이해가 잘 안된다면 아래 예를 보시고 위의 codePointAt 예를 비교하시면 이해가 잘 될 겁니다!&lt;br/&gt;
예) &quot;abcde&quot;.codePointBefore(1) 은 a의 유니코드인 97를 반환합니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;4. int codePointCount(int beginIndex, int endIndex)&lt;/h3&gt;&lt;br/&gt;
- 지정한 범위안에 있는 유니코드의 갯수를 리턴합니다 (그닥 안쓰일거 같긴한데... 흠 잘 모르겠네요)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;5. int compareTo(String anotherString)&lt;/h3&gt;&lt;br/&gt;
- 2개의 두 문자열을 비교하고 int형 값을 반환합니다&lt;br/&gt;
예) x.compareTo(y)&lt;br/&gt;
1. x 와 y가 동일한 경우 0을 반환합니다.&lt;br/&gt;
2. x 가 y보다 값이 큰 경우 양수를 반환합니다.&lt;br/&gt;
3. x 가 y보다 값이 작은 경우 음수를 반환합니다.&lt;br/&gt;
부가 설명 - 맨 첫자리부터 차례대로 비교하는 특성을 가지고 있으며, 2개의 스트링을 사전적으로 비교합니다.&lt;br/&gt;
비교는 스트링내의 각각의 문자의 유니코드 값에 근거해 행해집니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;6. int compareToIgnoreCase(String str)&lt;/h3&gt;&lt;br/&gt;
- compareTo와 모든 것이 같지만, 단 하나 대소문자를 무시한다는 점에서 다릅니다.&lt;br/&gt;
예) &quot;A&quot;.compareToIgnoreCase(&quot;a&quot;); -&gt; 대소문자가 무시 되므로 반환 값은 0입니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;7. String concat(String str)&lt;/h3&gt;&lt;br/&gt;
- 2개의 문자열을 붙여주는 메서드입니다.&lt;br/&gt;
예) String str1 = &quot;안녕하세요! &quot;;&lt;br/&gt;
String str2 = &quot;장현입니다~~~&quot;;&lt;br/&gt;
String result = str1.concat(str2);&lt;br/&gt;
System.out.println(result);&lt;br/&gt;
콘솔 출력 : 안녕하세요! 장현입니다~~~&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;8. boolean contains(CharSequence s)&lt;/h3&gt;&lt;br/&gt;
- contains 메서드는 특정 문자열이 포함되어 있는 지 확인하는 기능을 제공합니다.&lt;br/&gt;
특정 문자열이 포함되어 있다면 true 를, 없다면 false 를 반환합니다.&lt;br/&gt;
예) String str = &quot;안녕하세요 장현입니다!&quot;;&lt;br/&gt;
str.contains(&quot;장현&quot;); -&gt; &quot;장현&quot;이 포함되어 있으므로 true&lt;br/&gt;
str.contains(&quot;김도영&quot;); -&gt; &quot;장현&quot;이 포함되어 있지 않으므로 false&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;9. boolean contentEquals(CharSequence cs), contentEquals(StringBuffer sb)&lt;/h3&gt;&lt;br/&gt;
- 문자열이 100% 동일해야 true 를 반환하고 하나라도 다르면 false 를 반환합니다. (문자의 순서 등..)&lt;br/&gt;
contentEquals 가 equals 와 다른 점은 equals 는 String 끼리 비교하는 것에 반해 contentEquals 는 CharSequence 또는 StringBuffer 를 인자로 받아 String 과 비교합니다.&lt;br/&gt;
예) String str = &quot;장현&quot;;&lt;br/&gt;
StringBuffer sb = new StringBuffer(&quot;장현&quot;);&lt;br/&gt;
str.contentEquals(sb); -&gt; 반환 값은 true&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;10. static String copyValueOf(char[] data) , copyValueOf(char[] data, int offset, int count)&lt;/h3&gt;&lt;br/&gt;
- char[] 배열에 있는 값들을 하나의 String 으로 변환합니다. 그리고 offset 과 count 를 지정해 시작 지점에서 count 만큼 잘라 낼 수도 있습니다.&lt;br/&gt;
예) char[] temp = new char[4];&lt;br/&gt;
temp[0] = '인';&lt;br/&gt;
temp[1] = '스';&lt;br/&gt;
temp[2] = '유';&lt;br/&gt;
temp[3] = '틸';&lt;br/&gt;
String.copyValueOf(temp); -&gt; &quot;인스유틸&quot;;&lt;br/&gt;
String.copyValueOf(temp, 2, 1); -&gt; &quot;유&quot;;&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;11. boolean endsWith(String suffix)&lt;/h3&gt;&lt;br/&gt;
- 주어진 문자열이 파라미터로 끝나는지 체크합니다. 반환 값은 boolean 입니다.&lt;br/&gt;
예) String str = &quot;인스유틸&quot;;&lt;br/&gt;
str.endsWith(&quot;틸&quot;); -&gt; true&lt;br/&gt;
str.endsWith(&quot;유틸&quot;); -&gt; true&lt;br/&gt;
str.endsWith(&quot;인스유틸&quot;); -&gt; true&lt;br/&gt;
str.endsWith(&quot;유&quot;); -&gt; false&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;12. boolean equals(Object anObject)&lt;/h3&gt;&lt;br/&gt;
- 문자열이 주어진 파라미터와 동일한지 확인합니다. 이것 또한 boolean 이 반환됩니다.&lt;br/&gt;
예) String str = &quot;장현&quot;;&lt;br/&gt;
str.equals(&quot;장현&quot;); -&gt; true&lt;br/&gt;
str.equals(&quot;정채현&quot;); -&gt; false&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;13. boolean equalsIgnoreCase(String anotherString)&lt;/h3&gt;&lt;br/&gt;
- 비교대상 문자열을 대소문자 구분 없이 비교해서 동일하면 true, 그래도 다르다면 false 를 리턴합니다.&lt;br/&gt;
예) String str = &quot;abcde&quot;;&lt;br/&gt;
str.equalsIgnoreCase(&quot;aBcDE&quot;); -&gt; 대소문자를 구분하지 않으므로 true 입니다&lt;br/&gt;
str.equals(&quot;aBcDE&quot;); -&gt; equals 는 대소문자를 구분하므로 false 입니다&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;14. static String format(Locale l, String format, Object... args), static String format(String format, Object... args)&lt;/h3&gt;&lt;br/&gt;
- 지정된 위치에 값을 대입해서 문자열을 만들어내는 용도로 사용됩니다. 이건 예로 보는 것이 이해하기 더 빠르겠습니다.&lt;br/&gt;
예) String str = String.format(&quot;p1 : %s, p2 : %.2f&quot;, &quot;one&quot;, 1.234f); // String format 으로 변경된 값을 str 변수에 바인딩&lt;br/&gt;
System.out.println(str); -&gt; 콘솔 출력 : p1 : one, p2 : 1.23&lt;br/&gt;
해설 : %s는 스트링, %d는 숫자, %f는 실수에 대한 변경을 의미합니다.&lt;br/&gt;
&lt;br/&gt;
&lt;h5&gt;스트링의 %s의 대표적인 기능 및 예시는 다음과 같습니다.&lt;/h5&gt;&lt;br/&gt;&lt;br/&gt;
%s : 해당 위치의 스트링을 대체합니다.&lt;br/&gt;&lt;br/&gt;
%10s : 숫자(10)만큼 문자열 좌측(+)에 공백을 채워 문자열 길이를 만듭니다. 숫자보다 문자열 길이가 긴 경우에는 그대로 보여집니다.&lt;br/&gt;
ex) &quot;장현&quot; -&gt; &quot;________장현&quot; (_는 공백)&lt;br/&gt;&lt;br/&gt;
%-10s : 숫자(10)만큼 문자열 우측(-)에 공백을 채워 문자열 길이를 만듭니다. 숫자보다 문자열 길이가 긴 경우에는 그대로 보여집니다.&lt;br/&gt;
ex) &quot;장현&quot; -&gt; &quot;장현________&quot; (_는 공백)&lt;br/&gt;&lt;br/&gt;
%10.3s : 점(.)우측에 해당하는 숫자(3) 만큼 스트링을 자른 후 숫자(10)만큼 문자열 점(.)좌측에 공백을 채워 문자열 길이를 만듭니다.&lt;br/&gt;
ex) &quot;인스유틸&quot; -&gt; &quot;_______인스유&quot;&lt;br/&gt;&lt;br/&gt;
%-10.3s : 점(.)우측에 해당하는 숫자(3) 만큼 스트링을 자른 후 숫자(10)만큼 문자열 점(.)좌측에 공백을 채워 문자열 길이를 만듭니다.&lt;br/&gt;
ex) &quot;인스유틸&quot; -&gt; &quot;인스유_______&quot;&lt;br/&gt;&lt;br/&gt;
&lt;br/&gt;
스트링의 %d와 %f, 기타 %t에 대한 기능도 여러가지 있지만 추후에 더 추가하도록 하겠습니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;15. byte[] getBytes(), byte[] getBytes(Charset charset), byte[] getBytes(String charsetName)&lt;/h3&gt;&lt;br/&gt;
- 문자열을 인코딩 된 byte 형태로 넘겨줍니다. 매개변수 없이 getBytes() 메소드를 사용하면 플랫폼에 따른 default charset 을 사용합니다.&lt;br/&gt;
만일 특정 charset 을 지정할 경우 ISO-8859-1, euc-kr, utf-8 등의 charset 이 존재하는데 encoding 과 decoding 할 때 이 charset 을 맞춰서 해야합니다.&lt;br/&gt;
그러지 않을 경우 문자가 깨지는 현상이 발생하게 됩니다.&lt;br/&gt;
예) String str = &quot;Hello, 장현!&quot;; // 자바는 내부 문자열을 모두 유니코드 처리합니다.&lt;br/&gt;&lt;br/&gt;
// 유니코드 문자열을 UTF-8 캐릭터 바이트배열로 변환하여 반환&lt;br/&gt;
byte[] utf8 = str.getBytes(&quot;UTF-8&quot;); -&gt; 문자열을 utf-8로 인코딩 &lt;br/&gt;
new String(utf8, &quot;UTF-8&quot;) -&gt; 인코딩 된 바이트 배열을 다시 문자열로 디코딩 (UTF-8로 지정했으니 UTF-8로 디코딩 해야합니다. 다른 charset을 사용하면 문자가 깨집니다)&lt;br/&gt;&lt;br/&gt;
// 유니코드 문자열을 EUC-KR 캐릭터 바이트배열로 변환하여 반환&lt;br/&gt;
byte[] euckr = str.getBytes(&quot;EUC-KR&quot;);&lt;br/&gt;
new String(euckr, &quot;EUC-KR&quot;) -&gt; 인코딩 된 바이트 배열을 다시 문자열로 디코딩 (EUC-KR로 지정했으니 EUC-KR로 디코딩 해야합니다. 다른 charset을 사용하면 문자가 깨집니다)&lt;br/&gt;
&lt;br/&gt;
// 당연히 다른 바이트 배열이므로 사이즈가 다릅니다.&lt;br/&gt;
utf8.length -&gt; 14&lt;br/&gt;
euckr.length -&gt; 12&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;16. void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)&lt;/h3&gt;&lt;br/&gt;
- 주어진 문자 배열로부터 문자 배열을 추출해냅니다.&lt;br/&gt;
예) String str = &quot;인스유틸&quot;;&lt;br/&gt;
char[] dst = new char[4];&lt;br/&gt;
int srcBegin = 2; //srcBegin - 복제하기 위한 문자열에 있는 첫 번째 문자의 인덱스&lt;br/&gt;
int srcEnd = 4; //srcEnd - 복제하기 위한 문자열에 있는 마지막 문자의 다음 인덱스&lt;br/&gt;
int dstBegin = 0; // dstBegin - 여기 써있는 인덱스부터 채워 넣는다는 것입니다.&lt;br/&gt;
str.getChars(srcBegin, srcEnd, dst, dstBegin);&lt;br/&gt;
System.out.println(dst); -&gt; &quot;  유틸&quot; // dst - 복제되는 배열&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;17. boolean isEmpty()&lt;/h3&gt;&lt;br/&gt;
- 스트링이 비어있는 지 확인하는 메서드입니다. 만약 스트링 길이가 0이면 true, 그렇지 않으면 false를 반환합니다.&lt;br/&gt;
String str1 = &quot;&quot;;&lt;br/&gt;
String str2 = &quot;이수빈&quot;;&lt;br/&gt;
String str3 = null;&lt;br/&gt;
str1.isEmpty(); -&gt; true&lt;br/&gt;
str2.isEmpty(); -&gt; false&lt;br/&gt;
str3.isEmpty(); -&gt; null 값을 가지고 있는 스트링은 isEmpty 메서드를 사용하면 널포인트 익셉션이 뜨니 주의!&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;18. static String join(CharSequence delimiter, CharSequence... elements), static String join(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements)&lt;/h3&gt;&lt;br/&gt;
- 컬렉션이나 배열을 하나의 문자열로 묶어서 join 시킵니다. 예제로 보면 바로 이해하실 겁니다.&lt;br/&gt;
예) List&amp;lt;String&amp;gt; people = new ArrayList&lt;&gt;();&lt;br/&gt;
people.add(&quot;장현&quot;);&lt;br/&gt;
people.add(&quot;김도영&quot;);&lt;br/&gt;
people.add(&quot;이수빈&quot;);&lt;br/&gt;
people.add(&quot;이현승&quot;);&lt;br/&gt;
people.add(&quot;명재홍&quot;);&lt;br/&gt;
people.add(&quot;장석봉&quot;);&lt;br/&gt;
String peoples = String.join(&quot;, &quot;, people);&lt;br/&gt;
System.out.println(peoples);&lt;br/&gt;
콘솔 출력 값 : 장현, 김도영, 이수빈, 이현승, 명재홍, 장석봉&lt;br/&gt;
&lt;br/&gt;
어렵지 않습니다.&lt;br/&gt;
&lt;br/&gt;
join(&quot;추가할 문자&quot;, &quot;대상 list&quot;)&lt;br/&gt;
&lt;br/&gt;
join(&quot;추가할 문자&quot;, &quot;대상 Array&quot;)&lt;br/&gt;
&lt;br/&gt;
만약 stream의 collect() 안에서 사용하고 싶다면 아래와 같이 Collectors.joining() 을 사용하면 됩니다.&lt;br/&gt;
예) people.stream().collect(Collectors.joining(&quot;, &quot;)); -&gt; 장현, 김도영, 이수빈, 이현승, 명재홍, 장석봉&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;19. int indexOf(String str), int indexOf(String str, int fromIndex), int indexOf(int ch), int indexOf(int ch, int fromIndex)&lt;/h3&gt;&lt;br/&gt;
- 문자열 중 입력받은 문자가 있으면 해당 문자의 위치 (index) 값을 리턴하고 문자가 없으면 -1을 리턴합니다.&lt;br/&gt;
문자열 조회는 index 값 0부터 시작합니다. (왼쪽부터 읽기 시작함을 의미합니다)&lt;br/&gt;
예) String str = &quot;안녕하세요! 장현입니다!&quot;;&lt;br/&gt;
str.indexOf(&quot;요&quot;); -&gt; 4를 반환&lt;br/&gt;
str.indexOf(&quot;장현&quot;); -&gt; 7를 반환&lt;br/&gt;
str.indexOf(&quot;김한출&quot;); -&gt; -1를 반환&lt;br/&gt;
str.indexOf(&quot;!&quot;, 6); -&gt; &quot;!&quot;가 5와 12에 위치했는데 index가 6부터 시작하므로 12를 반환&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;20. int lastIndexOf(String str), int lastIndexOf(String str, int fromIndex), int lastIndexOf(int ch), int lastIndexOf(int ch, int fromIndex)&lt;/h3&gt;&lt;br/&gt;
- indexOf 는 왼쪽에서부터 조회를 하기 때문에 낮은 index 값을 먼저 조회하게 됩니다.&lt;br/&gt;
이와 반대로 lastIndexOf 는 끝에서부터 조회를 합니다&lt;br/&gt;
예) String str = &quot;안녕하세요! 장현입니다!&quot;;&lt;br/&gt;
str.lastIndexOf(&quot;!&quot;); -&gt; lastIndexOf는 뒤에서부터 시작하므로 12를 반환&lt;br/&gt;
str.lastIndexOf(&quot;!&quot;, 11); -&gt; 인덱스 11부터 보겠다는 뜻이으로 5를 반환&lt;br/&gt;
str.lastIndexOf(&quot;김한출&quot;); -&gt; -1를 반환&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;21. int	length()&lt;/h3&gt;&lt;br/&gt;
- 주어진 문자열의 길이를 리턴합니다&lt;br/&gt;
주의할 점은 index 값을 리턴하는 것이 아니라 실제 문장의 길이(int 형)를 리턴하는 것입니다.&lt;br/&gt;
예) String str = &quot;장현&quot;;&lt;br/&gt;
str.length() -&gt; 2를 반환&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;22. boolean matches(String regex)&lt;/h3&gt;&lt;br/&gt;
- 파라미터에서 원하는 정규표현식을 써서 문자열에 해당하는 패턴이 있는지 알아보는 메서드입니다.&lt;br/&gt;
예) String str = &quot;안녕하세요! 장현입니다!&quot;;&lt;br/&gt;
str.matches(&quot;.*장현*&quot;); -&gt; true 입니다&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;
String phonNumber = &quot;010-569-7836&quot;;&lt;br/&gt;
boolean flag = phonNumber.matches(&quot;01[06-9]-[0-9]{3,4}-[0-9]{4}&quot;);&lt;br/&gt;
System.out.println(flag); -&gt; true
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;23. String toString()&lt;/h3&gt;&lt;br/&gt;
- 문자열로 만들어 리턴하는 메서드입니다.&lt;br/&gt;
예) String str = &quot;장현&quot;;&lt;br/&gt;
str.toString(); -&gt; 문자열 &quot;장현&quot;을 리턴합니다&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;24. static String valueOf(Object obj), valueOf(long l), valueOf(int i), valueOf(float f), valueOf(double d),&lt;br/&gt;
valueOf(char[] data, int offset, int count), valueOf(char[] data), valueOf(char c), valueOf(boolean b)&lt;/h3&gt;&lt;br/&gt;
- toString 메서드와 비슷하나, 파라미터안에 null이 들어가면 문자열 null을 만들어서 담습니다.&lt;br/&gt;
예) String str = null;&lt;br/&gt;
String.valueOf(str); -&gt; 문자열 &quot;null&quot; 리턴, toString 이라면 널포인트 익셉션 발생합니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;25. String trim()&lt;/h3&gt;&lt;br/&gt;
- 대상 문자열의 앞 / 뒤 공백문자를 모두 제거하여 리턴해줍니다.&lt;br/&gt;
예) String str = &quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;안녕하세요&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;장현입니다!&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;;&lt;br/&gt;
str.trim(); -&gt; &quot;안녕하세요&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;장현입니다!&quot;  로 만들어줍니다&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;26. String 	toUpperCase(), toUpperCase(Locale locale)&lt;/h3&gt;&lt;br/&gt;
- 대상 문자열을 모두 대문자로 변환합니다. 파라미터에 Locale 클래스를 인자로 받을 수도 있습니다. 인자가 없으면 디폴트 로케일로 지정됩니다&lt;br/&gt;
예) String str = &quot;Insutil&quot;;&lt;br/&gt;
str.toUpperCase(); -&gt; &quot;INSUTIL&quot; 변환&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;27. String toLowerCase(), toLowerCase(Locale locale)&lt;/h3&gt;&lt;br/&gt;
- 대상 문자열을 모두 소문자로 변환합니다.&lt;br/&gt;
예) String str = &quot;Insutil&quot;;&lt;br/&gt;
str.toLowerCase() -&gt; &quot;insutil&quot; 변환&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;28. char[] toCharArray()&lt;/h3&gt;&lt;br/&gt;
- 스트링을 새로운 char 배열 형태로 변환합니다.&lt;br/&gt;
예) String str = &quot;정채현&quot;;&lt;br/&gt;
char[] charArray = str.toCharArray();&lt;br/&gt;
for(int i = 0; i &lt; charArray.length; i++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&quot;charArray[&quot; + i + &quot;] : &quot; + charArray[i]);&lt;br/&gt;
}&lt;br/&gt;
콘솔 출력 값 :&lt;br/&gt;
charArray[0] : 정&lt;br/&gt;
charArray[1] : 채&lt;br/&gt;
charArray[2] : 현&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;29. String 	substring(int beginIndex), substring(int beginIndex, int endIndex)&lt;/h3&gt;&lt;br/&gt;
- substring 은 2가지 메서드가 있습니다. 인자 하나를 받는 substring 메서드는 시작 인덱스부터 문자열 끝까지 잘라서 반환하고,&lt;br/&gt;
인자 두 개를 받는 substring 은 문자열의 시작 부분과 끝 부분을 지정해서 그 부분만 잘라서 반환합니다. 일반적으로 많이 쓰이는 건 후자입니다.&lt;br/&gt;
예) String str = &quot;0123456789&quot;;&lt;br/&gt;
str.substring(5); -&gt; &quot;56789&quot; 를 반환 (5번 index 를 포함하여 나머지 문자열을 반환합니다)&lt;br/&gt;
str.substring(5, 8); -&gt; &quot;567&quot; 를 반환 (5번 index 를 포함하고 8번 인덱스 미만(끝 인덱스 미포함)의 문자열을 반환합니다)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;30. String[] split(String regex), String[] split(String regex, int limit)&lt;/h3&gt;&lt;br/&gt;
- 입력받은 정규표현식 또는 특정 문자를 기준으로 문자열을 나누어 배열에 저장하여 리턴합니다.&lt;br/&gt;
예) String str = &quot;010-1234-5678&quot;;&lt;br/&gt;
String[] splitNum = str.split(&quot;-&quot;);&lt;br/&gt;
String str1 = splitNum[0]; -&gt; &quot;010&quot;&lt;br/&gt;
String str2 = splitNum[1]; -&gt; &quot;1234&quot;&lt;br/&gt;
String str3 = splitNum[2]; -&gt; &quot;5678&quot;&lt;br/&gt;
&lt;br/&gt;
- 다음은 인자 값을 두 개 받는 경우입니다. 두 번째 인자 값(int 형)은 배열의 크기를 결정합니다.&lt;br/&gt;
예) String str = &quot;010-1234-5678&quot;;&lt;br/&gt;
String[] splitNum = str.split(&quot;-&quot;, 2);&lt;br/&gt;
String str1 = splitNum[0]; -&gt; &quot;010&quot;&lt;br/&gt;
String str2 = splitNum[1]; -&gt; &quot;1234-5678&quot;&lt;br/&gt;
&lt;br/&gt;
참고로 String 으로 받는 인자는 정규표현식을 인자로 받기 때문에 아래와 같은 실수를 할 수 있으므로 주의하도록 합시다!&lt;br/&gt;
예) String str = &quot;안.녕.하.세.요&quot;;&lt;br/&gt;
str.split(&quot;.&quot;); -&gt; 이렇게 하면 안됩니다! (정규식에서 .는 임의의 문자를 의미하기 때문)&lt;br/&gt;
str.split(&quot;\\.&quot;); -&gt; 이렇게 해야 여러분이 원하는 작업물이 나옵니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;31. String replace(char oldChar, char newChar), String replace(CharSequence target, CharSequence replacement)&lt;/h3&gt;&lt;br/&gt;
- 자신이 바꾸고싶은 문자로 문자열을 치환시켜줍니다.&lt;br/&gt;
예) String str = &quot;인스유틸은 스타트업입니다!&quot;;&lt;br/&gt;
str = str.replace(&quot;스타트업&quot;, &quot;대기업&quot;); -&gt; &quot;인스유틸은 대기업입니다!&quot;&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;32. String 	replaceAll(String regex, String replacement)&lt;/h3&gt;&lt;br/&gt;
- replace 와 거의 비슷하나 한가지 다른 점은 replace는 첫 번째 인자 값으로 문자열을 받는 것에 반해 replaceAll은 첫 번째 인자 값으로 정규식을 받는다는 것입니다.&lt;br/&gt;
그래서 Replace는 특수문자로도 치환이 쉽지만 ReplaceAll은 정규식 특성상 특수문자로 치환이 어렵습니다.&lt;br/&gt;
예) String str = &quot;Go to the city... Boy...&quot;;&lt;br/&gt;
String rename = str.replaceAll(&quot;(?i)[b-c]&quot;, &quot;K&quot;);&lt;br/&gt;
System.out.println(rename); -&gt; 콘솔 출력 값 : Go to the Kity... Koy...&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;33. String replaceFirst(String regex, String replacement)&lt;/h3&gt;&lt;br/&gt;
- replaceFirst 메서드는 자신이 바꾸고싶은 문자열이 처음으로 해당할때만 치환시켜줍니다.&lt;br/&gt;
예) String str = &quot;장현은 인스유틸의 신입사원입니다. 인스유틸은 IT 기업입니다&quot;;&lt;br/&gt;
str = str.replaceFirst(&quot;인스유틸&quot;, &quot;9월&quot;);&lt;br/&gt;
System.out.println(str); -&gt; 콘솔 출력 값 : 장현은 9월의 신입사원입니다. 인스유틸은 IT 기업입니다&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;34. String intern()&lt;/h3&gt;&lt;br/&gt;
- 스트링 인스턴스의 문자열을 상수풀에 등록하는 메서드 입니다. 상수풀에 이미 존재하는 경우에는 해당 문자열의 주소를 반환합니다.&lt;br/&gt;
String str1 = &quot;장현&quot;;&lt;br/&gt;
String str2 = new String(&quot;장현&quot;);&lt;br/&gt;
str2 = str2.intern(); -&gt; str2에는 str1과 같은 주소값이 저장되게 된다(기존의 str2의 인스턴스는 가비지 컬렉트 됩니다)&lt;br/&gt;
if(str1 == str2) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&quot;출력 될까요?&quot;); -&gt; intern 메서드로 인해 같은 메모리 주소를 쓰므로 출력이 됩니다&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;35. boolean startsWith(String prefix), boolean startsWith(String prefix, int toffset)&lt;/h3&gt;&lt;br/&gt;
- 문자열을 파라미터를 기준으로 시작되는지를 확인합니다&lt;br/&gt;
예) String str = &quot;abcde&quot;;&lt;br/&gt;
System.out.println(str.startsWith(&quot;a&quot;)); -&gt; true (a부터 시작하는게 맞으므로 true 반환)&lt;br/&gt;
System.out.println(str.startsWith(&quot;ab&quot;)); -&gt; true (ab도 마찬가지)&lt;br/&gt;
System.out.println(str.startsWith(&quot;c&quot;, 2)); -&gt; true ( 인덱스 2는 c부터 시작하므로 true)&lt;br/&gt;
System.out.println(str.startsWith(&quot;c&quot;, 1)); -&gt; false ( 인덱스 1는 b부터 시작하므로 false)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;36. CharSequence subSequence(int beginIndex, int endIndex)&lt;/h3&gt;&lt;br/&gt;
- 문자열을 파라미터를 기준으로 범위를 지정해서 CharSequence 형태로 반환해줍니다.&lt;br/&gt;
여기서 CharSequence 란 String, StringBuffer, StringBuilder 등 의 상위 클래스입니다.&lt;br/&gt;
CharSequence 객체내 보관하는 문자열은 같은 String 클래스와 같은 유니코드라 하더라도 &lt;br/&gt;
마크업 문자를 사용하여 변형과 가공이 가능한 문자열이란 의미로 스타일 문자 또는 연속되는 문자라고 합니다.&lt;br/&gt;
예) String str = &quot;abcde&quot;;&lt;br/&gt;
System.out.println(str.subSequence(0, 4)); -&gt; abcd 출력&lt;br/&gt;
System.out.println(str.subSequence(1, 3)); -&gt; bc 출력&lt;br/&gt;
System.out.println(str.subSequence(2, 3)); -&gt; c 출력&lt;br/&gt;
System.out.println(str.subSequence(0, str.length())); -&gt; abcde 출력&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;p style=&quot;color: #005cbf; font-size: 30px; font-weight: bolder;&quot;&gt;
regionMatches 와 offsetByCodePoints 메서드를 제외한 String 관련 메서드들을 모두 정리했습니다. &lt;br/&gt;
regionMatches 와 offsetByCodePoints는 레퍼런스가 별로 없을 뿐더러 찾아서 살펴봤는데도 이해가 잘 안되서 추가하지 않았습니다.&lt;br/&gt;
&lt;br/&gt;
그럼 이상으로, 스트링 관련 포스팅을 마치겠습니다.&lt;br/&gt;
그럼 모두 좋은 하루 보내세요!
&lt;/p&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;</content><author><name>장현</name><email>daleyblind@naver.com</email></author><category term="[&quot;study&quot;]" /><summary type="html">안녕하세요! 신입사원 장현입니다. 포스팅에 맛들려서 이렇게 두 번째 포스팅을 하게 되었습니다. 부디 첫 포스팅보다 더 나아지길 바라며 글을 작성해봅니다... 자바로 프로그래밍하게 되면 자바의 문자열을 이리저리 가공하여 쓰는 경우가 허다합니다. 물론 여러분들처럼 프로그래밍 고수분들은 식은 죽 먹기로 화려하게 가공하시겠지만, 저같은 초보개발자는 막상 문자열을 자르거나 추출해야하는 업무를 맡으면 땀 뻘뻘 흘리면서 구글링을 하겠죠 ㅠㅠ</summary></entry><entry><title type="html">자바 정규식 (Regular Expression)</title><link href="https://insutil.github.io/study/2019/12/15/regex/" rel="alternate" type="text/html" title="자바 정규식 (Regular Expression)" /><published>2019-12-15T00:00:00+09:00</published><updated>2019-12-15T00:00:00+09:00</updated><id>https://insutil.github.io/study/2019/12/15/regex</id><content type="html" xml:base="https://insutil.github.io/study/2019/12/15/regex/">&lt;p&gt;안녕하세요 인스유틸의 신입사원 장현입니다..&lt;/p&gt;
&lt;p&gt;자바 정규식은 아무리 공부해도 새롭기 때문에 이렇게 포스팅하면 여러분들께 도움이 될까 이렇게 포스팅합니다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;정규식은 우리가 프로그래밍 할 때, 여러가지 이유로 많이 쓰입니다.&lt;/p&gt;
&lt;p&gt;예를 들어, 정규식은 문자열에서 특정 패턴을 찾거나, 교체 혹은 삭제하는 등 문자열을 원하는 형태로 편집하는 기능을 제공해줍니다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;참고로, 대부분의 언어는 정규식을 가지고 있는데, 사용법이 조금씩 다르다는 것을 알아두세요!&lt;/p&gt;
&lt;br/&gt;

&lt;h2&gt;JAVA 의 정규식&lt;/h2&gt;
&lt;br/&gt;
&lt;b&gt;반드시 알아야 할 정규식의 기본 문법&lt;/b&gt;
&lt;br/&gt;
&lt;ul&gt;
    &lt;li&gt; ^ : 문자열의 시작&lt;/li&gt;
    &lt;li&gt; $ : 문자열의 종료&lt;/li&gt;
    &lt;li&gt; . : 임의의 한 문자 (문자의 종류를 가리지 않음. 단, \는 넣을 수 없음)&lt;/li&gt;
    &lt;li&gt; * : 앞 문자가 없을 수도, 무한정 많을 수도 있음&lt;/li&gt;
    &lt;li&gt; + : 앞 문자가 하나 이상&lt;/li&gt;
    &lt;li&gt; ? : 앞문자가 없거나 하나 있음&lt;/li&gt;
    &lt;li&gt; [ ] : 문자의 집합이나 범위를 나타내며 두 문자 사이는 - 기호로 범위를 나타낸다. [ ]내에서 ^가 선행하여 존재하면 not을 의미한다 ex) [a-z] : a~z 사이의 문자, [^bc] : b,c를 제외한 나머지&lt;/li&gt;
    &lt;li&gt; { } : 횟수 또는 범위를 나타낸다. ex) {2,3} : 2글자에서 3글자, {5} : 5글자&lt;/li&gt;
    &lt;li&gt; ( ) : 소괄호 안의 문자를 하나의 문자로 인식&lt;/li&gt;
    &lt;li&gt; | : 패턴 안에서 OR 연산을 수행할 때 사용&lt;/li&gt;
    &lt;li&gt; \s : 공백 문자&lt;/li&gt;
    &lt;li&gt; \S : 공백 문자가 아닌 나머지 문자&lt;/li&gt;
    &lt;li&gt; \w : 알파벳이나 숫자&lt;/li&gt;
    &lt;li&gt; \W : 알파벳이나 숫자를 제외한 문자&lt;/li&gt;
    &lt;li&gt; \d : 숫자 [0-9]와 동일&lt;/li&gt;
    &lt;li&gt; \D : 숫자를 제외한 모든 문자&lt;/li&gt;
    &lt;li&gt; \ : 정규표현식 역슬래시(\)는 확장 문자. 역슬래시 다음에 일반 문자가 오면 특수문자로 취급하고 역슬래시 다음에 특수문자가 오면 그 문자 자체를 의미&lt;/li&gt;
    &lt;li&gt; ?i : 앞 부분에 (?i) 라는 옵션을 넣어주면 대소문자를 구문하지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;먼저 데이터가 문자열로 넘어온다면 문자열 시작 : ^, 문자열 끝 : $로 감싸주면 되고, 문자열이 아니라면 안쓰면 됩니다&lt;/h5&gt;
&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;
&lt;b&gt;다음은 위의 기본 문법에 대한 예제입니다&lt;/b&gt;
&lt;br/&gt;
&lt;b&gt;Example)&lt;/b&gt;
&lt;p&gt;1. 숫자 데이터만 받기&lt;/p&gt;
&lt;b&gt;-&gt; [0-9]*&lt;/b&gt;
&lt;p&gt;1234 같이 숫자로 넘어오는 경우 체크할 수 있습니다. &lt;br/&gt;하지만 &quot;1234&quot;처럼 문자로 감싸져 넘어오는 경우까지 체크할려면 &lt;b&gt;^[0-9]*$&lt;/b&gt;로 해야합니다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;2. 영문자만 받기&lt;/p&gt;
&lt;b&gt;-&gt; ^[a-zA-Z]*$&lt;/b&gt;
&lt;p&gt;[ ] 안의 패턴은 and 일 경우 ,(콤마)로 구분할 필요 없이 쭉 이어쓸 수 있습니다. (예시로, a-z(알파벳 소문자)와 A-Z(알파벳 대문자) 사이에 콤마가 없는것처럼요~)&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;3. 한글만 받기&lt;/p&gt;
&lt;b&gt;-&gt; ^[가-힣]*$&lt;/b&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;p&gt;4. 영어&amp;숫자만 받기&lt;/p&gt;
&lt;b&gt;-&gt; ^[a-zA-Z0-9]*$&lt;/b&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;p&gt;5. 이메일 형식으로 체크 : 예시) daleyblind@naver.com (ㅎㅎ 제 이메일입니다)&lt;/p&gt;
&lt;b&gt;-&gt; ^[a-zA-Z0-9]+\@[a-zA-Z]+\.[a-zA-Z]+$&lt;/b&gt;
&lt;p&gt;이메일은 살짝 복잡하므로 부가설명을 하겠습니다&lt;/p&gt;
&lt;p&gt;이메일은 일단 문자를 받으므로 ^로 시작합니다. 그리고 ID 역할을 하는 이메일 앞부분은 알파벳 대소문자와 영어 모두 올 수 있으므로 [a-zA-Z0-9]를 씁니다.
그리고 *를 쓰게되면 존재하지 않는 것도 체크하니 +를 씁니다. @나 .은 특수문자이므로 앞에 \(역슬래시)를 넣습니다.
&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;6. 핸드폰 체크 : 예시) 010-1234-5678&lt;/p&gt;
&lt;b&gt;-&gt; ^01(0|1|[6-9])\-(\d{4})\-(\d{4})$&lt;/b&gt;
&lt;br/&gt;
&lt;p&gt;7. 핸드폰 다중 체크 : 예시) 010-234-5678, 010 - 1234 - 5678, 010 1234 5678, 01012345678&lt;/p&gt;
&lt;b&gt;-&gt; ^01(0|1|[6-9])\s?\-?\s?(\d{3,4})\s?\-?\s?\d{4}$&lt;/b&gt;
&lt;p&gt;\s? : 공백이 있을 수도, 없을수도 있습니다.&lt;/p&gt;
&lt;p&gt;\-? : - 특수문자가 있을 수도, 없을 수도 있습니다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;8. 주민등록번호 체크 예시) 920902-1578939&lt;/p&gt;
&lt;b&gt;\d{6}\-[1-4]\d{6}&lt;/b&gt;
&lt;p&gt;해설 : \d는 [0-9]와 같으므로 뒤에 {6}는 0~9사이의 숫자 6개를 받겠다는 의미입니다. 마지막 [1-4]\d{6} 부분은 6개의 숫자를 받겠다는 건데 [1-4]와 \d가 겹쳐져 있는데
첫글자는 1~4의 숫자를 하나 받겠다는 뜻입니다.
&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;IP 주소 체크 예시) 192.168.0.55&lt;/p&gt;
&lt;b&gt;-&gt; \d{1,3}\.\d{1,3}\d{1,3}\.\d{1,3}&lt;/b&gt;
&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;

&lt;h3&gt;그럼 자바 정규표현식 사용법 중 하나를 채택해서, 실제 자바에서 어떻게 사용되는 지 알아보겠습니다.&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;background-color: rgb(255, 187, 0); color: rgb(255, 255, 255); font-size: 14pt;&quot;&gt;boolean result&lt;/span&gt;&lt;span style=&quot;background-color: rgb(255, 187, 0); color: rgb(255, 255, 255); font-size: 14pt;&quot;&gt;&amp;nbsp;= Pattern.matches(&quot;정규표현식&quot;, 검증데이터);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&quot;정규표현식&quot;에는 &quot;^[0-9a-zA-Z]*$&quot;과 같은 정규표현식이 들어가고, 검증데이터는 해당 정규표현식이 맞는지 확인 할 데이터가 들어갑니다.&lt;/p&gt;
&lt;p&gt;결과는 true/false로 return 됩니다.&lt;/p&gt;
&lt;br/&gt;&lt;br/&gt;

&lt;h4&gt;자바에서 Email 검증을 위한 코드 Ex)&lt;/h4&gt;
&lt;p&gt;String regEx = &quot;^[a-zA-Z0-9]+\\@[a-zA-Z]+\\.[a-zA-Z]+$&quot;;&lt;/p&gt;
&lt;p&gt;boolean regCheck = false;&lt;/p&gt;
&lt;p&gt;regCheck = Pattern.matches(regEx, &quot;daleyblind@naver.com&quot;);&lt;/p&gt;
&lt;p&gt;if(regCheck) { // true
    &lt;br/&gt;
    // 이메일 형식이 맞는 경우
    &lt;br/&gt;
    }else { // false
    &lt;br/&gt;
    // 이메일 형식이 아닌 경우
    &lt;br/&gt;
    }
&lt;/p&gt;
&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;
&lt;h2&gt;여기까지가 기본 문법이고, 좀만 더 파고 듭시다!&lt;/h2&gt;

&lt;br/&gt;
&lt;b&gt;1. 매칭될 문자를 지정하거나, 제외하는 방법입니다.&lt;/b&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;table border=&quot;1&quot;&gt;
    &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;정규식&lt;/th&gt;&lt;th&gt;설명&lt;/th&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;[abc]&lt;/td&gt;&lt;td&gt;a, b, c중 하나이면 일치 합니다.&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;[^abc]&lt;/td&gt;&lt;td&gt;a, b, c를 제외한 다른 글자 이면 일치합니다.&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;[a-zA-Z]&lt;/td&gt;&lt;td&gt;a 부터 z까지의 소문자 알파벳 이거나 A 부터 Z까지의 대문자 알파벳 중의 하나라면 일치합니다.(범위)&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;[a-d[m-p]]&lt;/td&gt;&lt;td&gt;a 부터 d까지, 또는 m 부터 p까지 중에 하나와 일치합니다: [a-dm-p] (합집합)&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;[a-z&amp;amp;&amp;amp;[def]]&lt;/td&gt;&lt;td&gt;d, e, f 중의 하나와 일치합니다. (교집합)&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;[a-z&amp;amp;&amp;amp;[^bc]]&lt;/td&gt;&lt;td&gt;b와 c를 제외한 a 부터 z까지 중의 하나와 일치합니다: [ad-z] (차집합)&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td nowrap=&quot;&quot;&gt;[a-z&amp;amp;&amp;amp;[^m-p]]&lt;/td&gt;&lt;td&gt;m부터 p 까지를 제외한, a 부터 z까지 중의 하나와 일치합니다: [a-lq-z] (차집합)&lt;/td&gt;&lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;b&gt;2. 미리 정의된 문자를 지정하는 방법입니다.&lt;/b&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;table border=&quot;1&quot;&gt;
    &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;정규식&lt;/th&gt;&lt;th&gt;설명&lt;/th&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;.&lt;/td&gt;&lt;td&gt;임의의 문자 (라인 종결자와 일치할 수도 하지 않을 수도 있음)&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;\d&lt;/td&gt;&lt;td&gt;숫자 : [0-9]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;\D&lt;/td&gt;&lt;td&gt;숫자가 아닌것: [^0-9]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;\s&lt;/td&gt;&lt;td&gt;공백 문자: [ \t\n\x0B\f\r]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;\S&lt;/td&gt;&lt;td&gt;공백 문자가 아닌것: [^\s]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;\w&lt;/td&gt;&lt;td&gt;알파벳 단어 문자(word 문자): [a-zA-Z_0-9]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;\W&lt;/td&gt;&lt;td&gt;알파벳 단어 문자가 아닌것: [^\w]&lt;/td&gt;&lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;b&gt;3. 수량 매칭&lt;/b&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;table border=&quot;1&quot;&gt;
    &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;Greedy&lt;/th&gt;&lt;th&gt;Reluctant&lt;/th&gt;&lt;th&gt;Possessive&lt;/th&gt;&lt;th&gt;의미&lt;/th&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;X?&lt;/td&gt;&lt;td&gt;X??&lt;/td&gt;&lt;td&gt;X?+&lt;/td&gt;&lt;td&gt;X가 없거나 한번 나옴&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;X*&lt;/td&gt;&lt;td&gt;X*?&lt;/td&gt;&lt;td&gt;X*+&lt;/td&gt;&lt;td&gt;X가 없거나 한번 이상 나옴&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;X+&lt;/td&gt;&lt;td&gt;X+?&lt;/td&gt;&lt;td&gt;X++&lt;/td&gt;&lt;td&gt;X가 한번 또는 여러번 나옴&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;X{n}&lt;/td&gt;&lt;td&gt;X{n}?&lt;/td&gt;&lt;td&gt;X{n}+&lt;/td&gt;&lt;td&gt;&lt;p&gt;X가 정확히&amp;nbsp;n번 나옴&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;X{n,}&lt;/td&gt;&lt;td&gt;X{n,}?&lt;/td&gt;&lt;td&gt;X{n,}+&lt;/td&gt;&lt;td&gt;X가 n번 이상 나옴&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;X{n,m}&lt;/td&gt;&lt;td&gt;X{n,m}?&lt;/td&gt;&lt;td&gt;X{n,m}+&lt;/td&gt;&lt;td&gt;X가 n이상 m이하로 나옴&lt;/td&gt;&lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;br/&gt;
&lt;p&gt;수량매칭은 각각 세 가지 방법을 사용할 수 있는데 조금씩 차이가 있습니다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;- &lt;b&gt;Greedy&lt;/b&gt; : 매칭을 위해서 입력된 문자열 전체를 읽어서 확인하고 뒤에서 한자씩 빼면서 끝까지 확인합니다.&lt;/p&gt;
&lt;p&gt;- &lt;b&gt;Reluctant&lt;/b&gt; : 입력된 문자열에서 한글자씩 확인해 나갑니다. 마지막에 확인하는 것은 전체 문자열 입니다.&lt;/p&gt;
&lt;p&gt;- &lt;b&gt;Possessive&lt;/b&gt; : 입력된 전체 문자열을 확인합니다. Greedy와 달리 뒤에서 빼면서 확인하지 않습니다.&lt;/p&gt;
&lt;br/&gt;&lt;br/&gt;

&lt;h3 style=&quot;color: darkred;&quot;&gt;첫 포스팅인 만큼 부족함이 많이 느껴지네요... &lt;br/&gt; 더 재밌고 자세하게 알려드렸어야 하는데, 그러지 못해 아쉽고 죄송스럽습니다.&lt;br/&gt;
다음에 더 나아지도록 노력하겠습니다! &lt;br/&gt;다들 좋은 하루 되세요!
&lt;/h3&gt;</content><author><name>장현</name><email>daleyblind@naver.com</email></author><category term="[&quot;study&quot;]" /><summary type="html">안녕하세요 인스유틸의 신입사원 장현입니다.. 자바 정규식은 아무리 공부해도 새롭기 때문에 이렇게 포스팅하면 여러분들께 도움이 될까 이렇게 포스팅합니다. 정규식은 우리가 프로그래밍 할 때, 여러가지 이유로 많이 쓰입니다. 예를 들어, 정규식은 문자열에서 특정 패턴을 찾거나, 교체 혹은 삭제하는 등 문자열을 원하는 형태로 편집하는 기능을 제공해줍니다. 참고로, 대부분의 언어는 정규식을 가지고 있는데, 사용법이 조금씩 다르다는 것을 알아두세요!</summary></entry><entry><title type="html">IoC &amp;amp; DI</title><link href="https://insutil.github.io/study/2019/12/05/ioc-di/" rel="alternate" type="text/html" title="IoC &amp; DI" /><published>2019-12-05T00:00:00+09:00</published><updated>2019-12-05T00:00:00+09:00</updated><id>https://insutil.github.io/study/2019/12/05/ioc-di</id><content type="html" xml:base="https://insutil.github.io/study/2019/12/05/ioc-di/">&lt;p&gt;IoC 컨테이너 &amp; DI&lt;/p&gt;
&lt;p&gt;Iversion of Control 은 Dependency Injection 이라고도 하며,&lt;/p&gt;
&lt;p&gt;spring application 에서는 객체의 생성, 관계설정, 사용, 제거 등의 작업을 코드가 아닌&lt;/p&gt;
&lt;p&gt;독립된 컨테이너가 담당함을 뜻합니다.&lt;/p&gt;
&lt;p&gt;그래서 스프링 컨테이너를 IoC 컨테이너 라고도 합니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;스프링에선 IoC를 담당하는 컨테이너를 빈 팩토리 또는 애플리케이션 컨텍스트 라고 칭합니다.&lt;/p&gt;
&lt;p&gt;스프링 컨테이너 = IoC 컨테이너 = 빈 팩토리 = 애플리케이션 컨텍스트 라고 봐도 &lt;/p&gt;
&lt;p&gt;크게 틀리지 않지만 객체의 생성과 관계 설정 이라는 DI 관점에서 볼때는&lt;/p&gt;
&lt;p&gt;스프링 컨테이너를 빈 팩토리 라고 할 수 있고, 빈의 생성부터, 관계설정, 제거에 이르기까지&lt;/p&gt;
&lt;p&gt;빈의 life cycle 관리 에 더해 기타 엔터프라이즈 애플리케이션 개발에 필요한 기능을 추가한 것을&lt;/p&gt;
&lt;p&gt;애플리케이션 컨텍스트 라고 보시면 됩니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;BeanFactory&lt;/p&gt;
    &lt;p&gt;● 애플리케이션 컴포넌트를 관리하는 저장소&lt;/p&gt;
    &lt;p&gt;● 빈 관련 메타설정 정보를 읽어들여 빈을 구성하고 제공&lt;/p&gt;
    &lt;p&gt;● life cycle interface 지원&lt;/p&gt;

&lt;p class=&quot;magt30 magb20&quot;&gt;빈 팩토리에서 일어나는 빈의 생성, 초기화 인터페이스 와 순서는 아래의 그림을 참고 하면 됩니다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/69914170-55721580-1484-11ea-81f6-793bd0279be4.png&quot; width=&quot;600&quot;&gt;

&lt;p class=&quot;magt20&quot;&gt;위 그림에서 특히 관심이 가는것은 BeanPostProcesser 라는 빈 후처리 인터페이스 입니다.&lt;/p&gt;
&lt;p&gt;여기서 빈 후처리란 빈이 최초에 생성되고 나서 빈의 설정을 후처리 함으로써 빈의 생명주기,&lt;/p&gt;
&lt;p&gt;빈팩토리의 생명주기에 관여할 수 있게 함을 뜻합니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;흔히 코딩을 할때 Autowired 어노테이션을 이용해서 빈을 DI 받습니다.&lt;/p&gt;
&lt;p&gt;그런데 어떻게 어노테이션 하나만으로 적절한 시점에 DI 할 후보 빈을 선정하고&lt;/p&gt;
&lt;p&gt;실제 빈을 주입하는지에 대해 궁금증을 가지신 분들이 계실지 모르겠는데..&lt;/p&gt;
&lt;p&gt;바로 빈 후처리기, BeanPostProcesser 에 의 후처리 될때 빈이 주입됩니다.&lt;/p&gt;
&lt;p&gt;후처리 순서는 그림에서 보듯이 아래와 같습니다.&lt;/p&gt;
  &lt;p class=&quot;magt20&quot;&gt;ⓐ BeanPostProcesser 의 postProcessBeforeInitialization (빈 초기화 전)&lt;/p&gt;
  &lt;p&gt;ⓑ InitializingBean's afterPropertiesSet&lt;/p&gt;
  &lt;p&gt;ⓒ custom init-method&lt;/p&gt;
  &lt;p&gt;ⓓ postProcessAfterInitialization ( 빈 초기화 후 )&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;ApplicationContext&lt;/p&gt;
    &lt;p&gt;● 스프링의 IoC 컨테이너는 일반적으로 애플리케이션 컨텍스트를 칭한다.&lt;/p&gt;
    &lt;p&gt;● BeanFactory 를 확장 (자체로 빈 팩토리 기능을 한다.)&lt;/p&gt;
    &lt;p&gt;● 메시지 소스 처리 기능, 이벤트 퍼블리싱, 리소스 로딩 등의 많은 추가 기능을 가진다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;ApplicationContext 가 추가적으로 가지는 기능에 대해 자세히&lt;/p&gt;
&lt;p class=&quot;magb20&quot;&gt;알고 싶다면 스프링 레퍼런스를 참고하시면 됩니다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/69914165-4ee39e00-1484-11ea-949e-d94b7d75001d.png&quot; width=&quot;600&quot;&gt;

&lt;p class=&quot;magt30&quot;&gt;보다시피 BeanFactory를 구현하고 있고, 위에서 언급한&lt;/p&gt;
&lt;p&gt;이벤트, 메시지, 리소스로더 관련 기능등을 구현하고 있습니다.&lt;/p&gt;
&lt;p&gt;(앞으로의 포스팅을 통해서 하나하나 전부 다뤄볼 예정입니다.)&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;지금까지 IoC 컨테이너 에 대해 최대한 간략하게 정리한 내용입니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;IoC 컨테이너의 가장 기초적이고 중요한 역할은 오브젝트를 생성하고 관리하는 것입니다.&lt;/p&gt;
&lt;p&gt;즉 빈 을 관리하는것이 IoC 컨테이너의 가장 중요한 임무인 것이죠.&lt;/p&gt;
&lt;p&gt;IoC 컨테이너가 빈을 생성하고 관리하기 위해서는 POJO 클래스와 빈설정 메타정보가 필요합니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;부트 기반으로 대부분의 자바 웹 애플리케이션을 제작하는 요즘은&lt;/p&gt;
&lt;p&gt;xml과 같은 외부 설정파일을 이용하기 보다는 어노테이션 기반으로 빈 설정을 합니다.&lt;/p&gt;
&lt;p&gt;애플리케이션 컨텍스트를 저희가 코드로 생성할 일도 거의 없습니다.&lt;/p&gt;
&lt;p&gt;물론 이미 생성된 애플리케이션 컨텍스트를 활용할 수는 있습니다.&lt;/p&gt;
&lt;p&gt;지금 부터는 xml 을 이용한 빈설정, 어노테이션을 이용한 빈 설정 두방법 모두를 간단히 테스트 해보겠습니다.&lt;/p&gt;
&lt;p class=&quot;magt50&quot;&gt;단...... 다음 포스팅에서요~~ 오늘은 이만..&lt;/p&gt;</content><author><name>김도영</name><email>kdy6721@gmail.com</email></author><category term="[&quot;study&quot;]" /><summary type="html">IoC 컨테이너 &amp; DI Iversion of Control 은 Dependency Injection 이라고도 하며, spring application 에서는 객체의 생성, 관계설정, 사용, 제거 등의 작업을 코드가 아닌 독립된 컨테이너가 담당함을 뜻합니다. 그래서 스프링 컨테이너를 IoC 컨테이너 라고도 합니다.</summary></entry><entry><title type="html">Blog Posting</title><link href="https://insutil.github.io/etc/2019/11/30/blog-posting/" rel="alternate" type="text/html" title="Blog Posting" /><published>2019-11-30T00:00:00+09:00</published><updated>2019-11-30T00:00:00+09:00</updated><id>https://insutil.github.io/etc/2019/11/30/blog-posting</id><content type="html" xml:base="https://insutil.github.io/etc/2019/11/30/blog-posting/">&lt;p&gt;야심차게 블로그를 만들었으나 역시나 실무에서 경험한 내용..&lt;/p&gt;
&lt;p&gt;개인적으로 학습한 내용을 또 다시 시간을 내어 포스팅 한다는게 쉽지는 않은것 같습니다.&lt;/p&gt;
&lt;p&gt;포스팅 하고 싶은 내용은 차고 넘쳐나는데 말이죠;;&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;일단 이번 포스팅은 저희 insutil 구성원 들에게 포스팅 하는 방법을 설명하는게 목적입니다.&lt;/p&gt;
&lt;p&gt;막상 블로그는 만들어 놓고 지금껏 제대로 설명을 안하고 있었네요. 쩝;&lt;/p&gt;
&lt;p&gt;주말 아침부터 혼자 일어나 씻지도 않고 부랴부랴 간단히 적어보겠습니다;&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;먼저 저희 블로그는 jekyll 을 사용해 만들어졌습니다.&lt;/p&gt;
&lt;p&gt;jekyll 에 대한 자세한 설명은 생략하구요, 그저 간단한 정적사이트 생성기 정도라고 이해하시면 됩니다.&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;jekyll 을 설치하고 빌드해서 포스팅 하기 위해서는 ruby 를 설치 하셔야 합니다.&lt;/p&gt;
&lt;p&gt;cmd 에서 ruby -v 를 통해 확인해 봅니다. (아마 설치가 안되어 있으리라 생각됩니다.)&lt;/p&gt;
&lt;p&gt;설치가 안되어 있다면 각자의 운영체제에 맞는 ruby 를 설치하시면 됩니다. (워낙 간단하니 생략합니다.)&lt;/p&gt;

&lt;p&gt;설치가 완료되었으면 jekyll 을 설치해보죠.&lt;/p&gt;
&lt;p&gt;ruby 에서는 라이브러리를 gem 이라 하는데 이 gem 명령어를 통해 각종 패키지 설치가 가능합니다.&lt;/p&gt;
&lt;p&gt;npm 과 비슷하다고 보시면 될거 갑습니다.&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;cmd 에서 gem jekyll 을 입력합니다. (jekyll 설치)&lt;/p&gt;
&lt;p class=&quot;fwb&quot;&gt;자세한 내용은 https://jekyllrb.com/docs/ 참고 요망&lt;/p&gt;
&lt;p&gt;gem install bundler, bundle install 실행&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;그리고 저희회사 github repository 에서 repo 를 clone 해야겠지요.&lt;/p&gt;
&lt;p class=&quot;fwb&quot;&gt;(github username 을 알려주셔야 collaborators 추가 할 수 있으니 slack 을 통해서 알려주세요~~!!)&lt;/p&gt;

&lt;p&gt;자 그럼 이제 jekyll 을 이용해 블로그 포스팅을 위한 사전 준비는 끝이 났습니다.&lt;/p&gt;
&lt;p&gt;지금부터는 해당 글의 목적에 맞게 블로그 포스팅 을 타켓으로 해서 최대한 간략히 적겠습니다.&lt;/p&gt;

&lt;p class=&quot;fwb&quot;&gt;※ jekyll 은 정해진 포맷에 따라 글을 작성해야 하는데 간단히 나열하겠습니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;ⓐ _post 폴더 하위에 YEAR-MONTH-DAY-title.html 로 파일 생성. (markdown 아님)&lt;/p&gt;
&lt;p&gt;ⓑ 모든 글은 레이아웃,카테고리 등을 포함하는 메타정보를 최상위에 적어준다.&lt;/p&gt;
&lt;p&gt;ⓒ 메타 정보 포함 작성이 끝났으면 cmd 에서 해당 폴더로 이동 'bundle exec jekyll serve' 입력&lt;/p&gt;
&lt;p&gt;ⓓ 그럼 node 처럼 local 에서 블로그를 확인할 수 있습니다. (127.0.0.1:4000)&lt;/p&gt;
&lt;p&gt;ⓔ 작성한 글이 잘 반영되었다면 이제 blog 의 remote repo 에 배포.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;위 내용중 ⓑ 메타정보에 대한 샘플이 보고 싶으시면&lt;/p&gt;
&lt;p&gt;제가 앞서 작성한 포스팅 파일을 확인 하시면 됩니다.&lt;/p&gt;
&lt;p&gt;그리고 배포는 bundle exec jekyll serve 명령어 를 실행했을때 이미 블로그 build 는 끝이 났습니다.&lt;/p&gt;
&lt;p&gt;cmd 에서 'rake publish' 입력하시면 자동으로 배포가 되도록 작업이 되어 있습니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;그리고 remote repo 의 master branch 는 최종 build 한 내용물이 올라갑니다. &lt;/p&gt;
&lt;p&gt;(rake publish 명령 실행시 master branch 로 푸시합니다. 그 외에 따로 master branch 에 푸시해서는 안됩니다.)&lt;/p&gt;
&lt;p&gt;저희가 local 에서 작성하고 수정한 내용은 ( blog full source ) source branch 로 관리됩니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;여기까지 블로그 포스팅 작성을 위한 간단한 설명이었습니다.&lt;/p&gt;
&lt;p&gt;텍스트로 설명하려니 한계가 있네요, 특히 메타정보에 대해서 추가 설명이 필요할것 같은데..&lt;/p&gt;
&lt;p&gt;궁금하신 내용은 slack 을 통해서 문의주시면 됩니다.&lt;/p&gt;</content><author><name>김도영</name><email>kdy6721@gmail.com</email></author><category term="[&quot;etc&quot;]" /><summary type="html">야심차게 블로그를 만들었으나 역시나 실무에서 경험한 내용.. 개인적으로 학습한 내용을 또 다시 시간을 내어 포스팅 한다는게 쉽지는 않은것 같습니다. 포스팅 하고 싶은 내용은 차고 넘쳐나는데 말이죠;;</summary></entry><entry><title type="html">Java static</title><link href="https://insutil.github.io/study/2019/11/19/static/" rel="alternate" type="text/html" title="Java static" /><published>2019-11-19T13:00:00+09:00</published><updated>2019-11-19T13:00:00+09:00</updated><id>https://insutil.github.io/study/2019/11/19/static</id><content type="html" xml:base="https://insutil.github.io/study/2019/11/19/static/">&lt;p&gt;블로그 개설 후 제대로 된 첫 포스팅 작성입니다.&lt;/p&gt;
&lt;p&gt;첫 포스팅 이니 만큼 어떤 내용을 다뤄야 하나 고민을 하다가&lt;/p&gt;
&lt;p&gt;기초부터 잘 다지고 완전히 내것으로 만들자는 생각에 그중 처음으로&lt;/p&gt;
&lt;p class=&quot;magb30&quot;&gt;자바의 static 키워드에 대해 얘기해 볼까합니다.&lt;/p&gt;

&lt;p&gt;static 키워드는 프로그래밍 에서 '전역', '정적', 거기에 '공유' 등의 의미로 해석될 수 있습니다.&lt;/p&gt;
&lt;p&gt;static 에 대해 얘기할때 빠질 수 없는게 메모리 할당과 관련된 것인데,&lt;/p&gt;
&lt;p class=&quot;magb30&quot;&gt;java 에서 메모리를 할당 받는 방법은 크게 2가지로 볼 수 있습니다.&lt;/p&gt;

&lt;p class=&quot;fwb&quot;&gt;① 객체(인스턴스) 생성&lt;/p&gt;
&lt;p class=&quot;fwb magb30&quot;&gt;② static 사용&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;1&quot; src=&quot;https://user-images.githubusercontent.com/55611187/69144846-9aef2400-0b0f-11ea-9d62-bd5db26dd6f8.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;위 그림을 보면 객체 생성을 하지않아 메모리를 할당받지 못했기 때문에&lt;/p&gt;
&lt;p class=&quot;magb20&quot;&gt;num 이라는 변수에 접근할 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;2&quot; src=&quot;https://user-images.githubusercontent.com/55611187/69144910-c114c400-0b0f-11ea-87de-b50284309530.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;이번 그림을 보시면 new 연산자를 통해 객체(인스턴스)를 생성.&lt;/p&gt;
&lt;p class=&quot;magb20&quot;&gt;메모리에 할당이 되었기 때문에 접근에 문제가 없는걸 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음으로 static 사용한 예를 보시죠.&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;3&quot; src=&quot;https://user-images.githubusercontent.com/55611187/69144925-ca059580-0b0f-11ea-958f-09944e385f97.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;변수를 static 으로 선언했을 뿐인데 객체 생성 없이 class를 통해 바로 접근 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;그럼 여기서 한가지 드는 의문.. 그렇다면 굳이 객체 생성을 하지 않고&lt;/p&gt;
&lt;p&gt;가능한 모든 변수 와 메서드를 static 으로 선언해서 사용하면 되지 않을까??&lt;/p&gt;
&lt;p&gt;여기에서 static 의 장.단점이 극명하게 드러납니다.&lt;/p&gt;

&lt;p&gt;그것을 다루기 전에 JVM의 memory 구조에 대해 잠깐 얘기해 보겠습니다.&lt;/p&gt;
&lt;img width=&quot;560&quot; alt=&quot;1&quot; src=&quot;https://user-images.githubusercontent.com/55611187/69149816-a85ddb80-0b1a-11ea-9eae-d5789d314f7b.png&quot;&gt;
&lt;p&gt;사실 JVM 구조만 가지고 얘기를 해도&lt;/p&gt;
&lt;p&gt;포스팅의 모든 지면을 할애해도 부족할 만큼 언급하고 싶은 내용이 많습니다만.. &lt;/p&gt;
&lt;p&gt;static keyword 관련된 내용만 최대한 간단히 훓고 지나가겠습니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;제일 먼저 개발자가 작성한 .java 파일을 compiler 가 .class (byte code)로 변환 합니다.&lt;/p&gt;
&lt;p&gt;다음으로 변환된 .class 파일을 class loder가 JVM의 메모리 영역( Runtime data area ) 에 적재합니다.&lt;/p&gt;
&lt;p&gt;메모리에 적재된 class 파일은 execution engine 에 의해 실행됩니다.&lt;/p&gt;

&lt;p&gt;그리고 보시면 Method Area (Class Area, Code Area 라고도 불립니다.) 가 보입니다.&lt;/p&gt;
&lt;p&gt;바로 이 Method Area에 Static 변수가 저장됩니다. (그 외에도 variable, method, type, constant 관련 정보도 저장.)&lt;/p&gt;
&lt;p&gt;저장되는 시점은 class 파일이 메모리에 로드되는 시점입니다.&lt;/p&gt;
&lt;p&gt;즉 데이터의 메모리 할당이 컴파일 시점에 이루어 지는 것입니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;이렇게 메모리에 로드되고 나면 런탐임 중에 필요할 때 마다 동적으로 할당 및 해제되는&lt;/p&gt;
&lt;p&gt;동적 데이터와 달리 어플리케이션의 실행 부터 종료까지 메모리에 로드된 채로 남아 있게 됩니다.&lt;/p&gt;

&lt;p&gt;이런 특징으로 인해 static 은 그 기능 과 역할이 분명히 구분되어 집니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;java에서 static 이 사용되는 영역은 변수, 메서드, 클래스가 있고 static 블럭 도 존재합니다.&lt;/p&gt;
&lt;p&gt;하나씩 짚어보겠습니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;● static 변수 (클래스 변수)는&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 하나의 메모리 영역을 모든 인스턴스가 공유합니다.&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 특정 인스턴스에 종속되지 않습니다.&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 종합해보면 인스턴스 없이도 사용 가능하다~ 가 됩니다.&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;● static 메서드&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 클래스 메서드 라고도 하고, 상속 클래스에서 보이지 않습니다.&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- Override 할 수 없습니다.&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;● static 클래스&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 중첩 클래스(nested class) 에만 사용 가능합니다.&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 상위 클래스의 멤버 필드 중에는 static 필드에만 접근 가능합니다.&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 이런 특징은 유사 클래스를 하나로 묶어 관리와 사용을 용이하게 할 수 있습니다.&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;● static 블럭&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 클래스의 내부에 만들 수 있는 초기화 블럭입니다.&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 클래스가 메모리에 로드 될때(초기화 될때) 단 한번 실행됩니다.&lt;/p&gt;

 &lt;p class=&quot;magt30&quot;&gt;여기까지 java 에서 static 이 사용되는 영역과 그에 따른 의미를 살펴보았습니다.&lt;/p&gt;

 &lt;p class=&quot;magt20&quot;&gt;그러면 이제 static 의 장.단점을 정리해보겠습니다.&lt;/p&gt;

 &lt;p class=&quot;magt20&quot;&gt;● 장점&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- 공유되는 자원입니다. 인스턴스 생성때 마다 메모리에 올리고 초기화 하지 않고, 최초의 자원을 모든 인스턴스가 공유합니다.&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- 위와 같은 이유로 잘만 사용하면 메모리를 효율적으로 사용할 수 있습니다.&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- 인스턴스 생성없이 바로 참조하기 때문에 속도가 빠릅니다.&lt;/p&gt;

 &lt;p class=&quot;magt20&quot;&gt;● 단점&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- 무분별한 사용은 메모리 오남용을 발생시킬 수 있습니다.&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- 전역적인 특징으로 인해 추론과 테스트를 힘들게 합니다.&lt;/p&gt;
       &lt;p class=&quot;magl30&quot;&gt;(공유되는 자원이므로 코드의 여러부분에서 영향을 받을 수 있게 되므로 추적이 힘들어 집니다.)&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- 객체 지향의 패러다임과 맞지 않습니다.&lt;/p&gt;
       &lt;p class=&quot;magl30&quot;&gt;(static 변수는 각 객체의 데이터들이 외부로 부터 함부로 접근 할 수 없고 수정될 수 없어야 한다는 캡슐화에 위배됩니다.)&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- 오버라이딩 할 수 없는 멤버들로 인해 클래스의 확장성을 떨어뜨립니다.&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- java 와 같은 객체지향 언어들의 장점인 재사용성 을 떨어뜨리고 interface 구현에 사용할 수 없습니다.&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;이렇게 보면 단점이 더 많은것 같은데요.&lt;/p&gt;
&lt;p&gt;실제로 제가 본 어떤 개발자의 포스팅에서는&lt;/p&gt;
&lt;p&gt;java 에서의 static 사용을 거의 &lt;b&gt;악&lt;/b&gt;으로 규정하는 내용도 보았습니다;;&lt;/p&gt;
&lt;p&gt;하지만 분명 제대로 알고 사용한다면 단점을 최소화 하고 장점을 극대화 해서&lt;/p&gt;
&lt;p&gt;어플리케이션 성능에 도움이 될 수있습니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;마지막으로 한가지만 더 언급하자면 java에서 final 변수에는 관례적으로 static 을 붙여서 사용하는 경우가 많습니다.&lt;/p&gt;
&lt;p&gt;왜 그런가를 생각해 보면 static 이라는 녀석에 대해 또 한번 곱씹을 수 있는 부분 인데요.&lt;/p&gt;
&lt;p&gt;final 은 단한번  초기화 가능함을 뜻합니다.&lt;/p&gt;
&lt;p class=&quot;magt30&quot;&gt;다시 말해 해당 변수의 용도와 의미가 최초 한번 설정되면, 변하지 않고 고정되어야 한다는 뜻입니다.&lt;/p&gt;
&lt;p&gt;클래스의 모든 인스턴스에서 사용해야 하는 데이터고 바뀌지 않을 꺼라면, 인스턴스가 생성될때 마다&lt;/p&gt;
&lt;p&gt;메모리를 할당받고 초기화 시키지 말고, 최초 한번 메모리에 올리고 그 공간을 모든 인스턴스가 쭈~우욱~&lt;/p&gt;
&lt;p&gt;사용하게 한다면??? 매번 메모리를 할당 하는것 보다 효율적일 수 있습니다.&lt;/p&gt;
&lt;p&gt;또 final은 상수와 같은 (정확히 final = 상수 는 아닙니다.) 의미이니 동시성 문제도 없습니다.&lt;/p&gt;
&lt;p&gt;이런 이유로 멤버 final 변수는 static final로 선언하는 것이 관례가 된거 같습니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;여기까지 java 의 static 에 대해 얘기해보았습니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;두서없는 글 읽어주셔서 감사합니다.&lt;/p&gt;</content><author><name>김도영</name><email>kdy6721@gmail.com</email></author><category term="[&quot;study&quot;]" /><summary type="html">블로그 개설 후 제대로 된 첫 포스팅 작성입니다. 첫 포스팅 이니 만큼 어떤 내용을 다뤄야 하나 고민을 하다가 기초부터 잘 다지고 완전히 내것으로 만들자는 생각에 그중 처음으로 자바의 static 키워드에 대해 얘기해 볼까합니다.</summary></entry><entry><title type="html">인스유틸 블로그 첫걸음</title><link href="https://insutil.github.io/instory/study/2019/11/17/created-blog/" rel="alternate" type="text/html" title="인스유틸 블로그 첫걸음" /><published>2019-11-17T13:00:00+09:00</published><updated>2019-11-17T13:00:00+09:00</updated><id>https://insutil.github.io/instory/study/2019/11/17/created-blog</id><content type="html" xml:base="https://insutil.github.io/instory/study/2019/11/17/created-blog/">&lt;h2 class=&quot;&quot;&gt;• 동기&lt;/h2&gt;
&lt;p&gt;2019년 무더위가 한창인 8월 인스유틸 에 입사 하면서 그동안 접해보지 않았던&lt;/p&gt;
&lt;p&gt;기술로 개발을 하는 프로젝트에 곧바로 투입 되었다.&lt;/p&gt;

&lt;p&gt;덕분에? 많은 학습이 필요했고 늘 그렇듯 검색 또 검색을 하며 이런 저런 지식을&lt;/p&gt;
&lt;p&gt;머리속에 구겨넣던 중 우아한 형제들의 기술 블로그를 알게 되었다.&lt;/p&gt;
&lt;p&gt;블로그 이글 저글을 읽어 보면서 동료들과 함께 성장해 나가기 위한 그들의 모습이,&lt;/p&gt;
&lt;p&gt;기업 문화가 좋아보였다.&lt;/p&gt;

&lt;p&gt;마침 그때 나는 프로젝트를 진행하며 소통과 공유에 답답함을 많이 느끼던 중이었다.&lt;/p&gt;

&lt;p&gt;부러우면 지는거다 라는 우스갯 소리처럼 부러워만 하기보다 우리회사 도 이런 블로그를&lt;/p&gt;

&lt;p&gt;만들어 보면 좋겠다는 생각을 했고, 생각을 했으면.. 어떻게?? 그렇다 바로 실행에 옮겨야지!&lt;/p&gt;


&lt;p&gt;우아한형제들의 기술 블로그도 그러하고 요즘 github page 를 활용한 블로그 가 대세인것 같다.&lt;/p&gt;

&lt;p&gt;대세는 거스르려 하지 말고 따르자.&lt;/p&gt;

&lt;p&gt;바로 jekyll 을 활용한 블로그 생성에 돌입.&lt;/p&gt;

&lt;p&gt;잠깐씩 짬을 내서 1~2일 이면 끝날 줄 알았던 블로그 작업이 theme 를 고르는 것 부터

&lt;p&gt;plugin 연동 등을 하다 보니 갖은 삽?질 과 오기로 안되는걸 부여잡고 끙끙대고,&lt;/p&gt;

&lt;p&gt;이런저런 핑계로 미루다보니 3주정도의 시간이 걸린것 같다.&lt;/p&gt;

&lt;h2 class=&quot;magt50&quot;&gt;• 참여&lt;/h2&gt;
&lt;p&gt;이렇게 블로그는 만들어 졌지만 구성원 들이 얼마나 받아들이고 활성화가 될지는 미지수다.&lt;/p&gt;

&lt;p&gt;지금 블로그를 만들고 간단히 소회를 적어내려 가면서도 나 또한 이런 글을 적는다는게&lt;/p&gt;

&lt;p&gt;적잖이 부담이 되는게 사실이다.&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;나혼자를 위해 써내려 가는 일기가 아니라 모두와 공유하기 위한 글을 적는다는것.&lt;/p&gt;

&lt;p&gt;나름의 용기도 필요하고 의지가 동반되어야 가능하다고 생각한다.&lt;/p&gt;

&lt;p&gt;기본적으로 이 블로그는 인스유틸 구성원들이 업무를 진행하며&lt;/p&gt;

&lt;p&gt;각자가 배우고 느끼고 학습한 내용을 혼자의 기억으로 남기지 말고 기록을 함으로써&lt;/p&gt;

&lt;p&gt;함께 공유하고, 함께 배우며, 함께 성장해 나가는 그 첫걸음 이 되었으면 좋겠다.&lt;/p&gt;

&lt;p&gt;뭐든지 새로운것을 처음 받아들일때는 어느정도의 진입장벽은 있기 마련이고, 그것을 받아들이고&lt;/p&gt;

&lt;p&gt;이 블로그를 만들고자 한 취지를 공감해 주었으면 한다.&lt;/p&gt;

&lt;h2 class=&quot;magt50&quot;&gt;• 이제부터 시작&lt;/h2&gt;
&lt;p&gt;인스유틸 이라는 회사는 자신의 분야에서 20년 이상의 경력을 가진 개발자 와 신입 주니어 개발자,&lt;/p&gt;
&lt;p&gt;그리고 여기저기서 10여년간 개발을 해온 나 까지 포함해 개발자 8명, 경영지원을 해주시는 분 까지&lt;/p&gt;
&lt;p&gt;약 10명 정도로 구성된 이제 시작하는 작은 회사이다.&lt;/p&gt;

&lt;p&gt;그러다 보니 체계를 잡아나가야 할 부분들이 많다는 생각이 든다.&lt;/p&gt;
&lt;p&gt;코딩 표준화 부터, 프로젝트를 시작하고 마치기 까지 일정관리, 이슈관리,&lt;/p&gt;
&lt;p&gt;각자의 업무진행 상황을 공유하고 진행 하면서 생기는 이슈를 공론화 하고 &lt;/p&gt;
&lt;p&gt;이를 통해 끊임없이 소통하고 함께 성장해 나갈 수 있기를 바래본다.&lt;/p&gt;

&lt;p&gt;일을 더 잘하고 싶은 마음 누구나 같을것이다.&lt;/p&gt;
&lt;p&gt;좋은 구성원(개발자)은 내가 얼마나 많이 알고, 뛰어난 역량을 가졌냐가 아니라,&lt;/p&gt;
&lt;p&gt;얼마나 많은 사람이 자신으로 인해 좋은 생각을 하고 좋은 변화를 받아들이고,&lt;/p&gt;
&lt;p&gt;그로 인해 좋은 성과를 낼수 있게 하는 사람 이라고 생각한다.&lt;/p&gt;
&lt;p&gt;그를 통해 자신또한 또 한계단 성장 할 수 있으리라 본다.&lt;/p&gt;

&lt;p&gt;변화에 대해 열린 마음을 갖고 함께 성장해 나갈 인스유틸 구성원들 모두를 응원한다.&lt;/p&gt;</content><author><name>김도영</name><email>kdy6721@gmail.com</email></author><category term="[&quot;inStory&quot;, &quot;study&quot;]" /><summary type="html">• 동기 2019년 무더위가 한창인 8월 인스유틸 에 입사 하면서 그동안 접해보지 않았던 기술로 개발을 하는 프로젝트에 곧바로 투입 되었다.</summary></entry></feed>